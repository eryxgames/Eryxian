<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced TTRPG World Generation Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .control-panel { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); }
        .control-panel label { display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.875rem; }
        .control-panel input, .control-panel select { width: 100%; padding: 0.375rem; border-radius: 0.375rem; background-color: #475569; border: 1px solid #64748b; color: #f1f5f9; font-size: 0.875rem; }
        .control-panel input[type="range"] { padding: 0; }
        canvas { background-color: #020617; border: 2px solid #334155; border-radius: 0.75rem; display: block; cursor: crosshair; }
        .tab { padding: 0.5rem 1rem; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s ease-in-out; font-size: 0.875rem; }
        .tab:hover { background-color: #1e293b; }
        .tab.active { color: #6366f1; border-color: #6366f1; font-weight: 600; }
        .tab-content { display: none; }
        .tab-content.active { display: flex; }
        .template-card { background: #334155; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.75rem; cursor: pointer; transition: all 0.2s; margin-bottom: 0.5rem; }
        .template-card:hover { border-color: #6366f1; }
        .template-card.selected { border-color: #6366f1; background: #4338ca; }
        .layer-toggle { display: flex; align-items: center; justify-content: space-between; padding: 0.375rem; background: #475569; border-radius: 0.375rem; margin: 0.25rem 0; font-size: 0.875rem; }
        .toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .toggle-switch input { display: none; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #64748b; transition: .3s; border-radius: 24px; }
        .slider-toggle:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked + .slider-toggle { background-color: #6366f1; }
        input:checked + .slider-toggle:before { transform: translateX(20px); }
        .param-group { margin: 0.5rem 0; }
        .value-display { color: #a78bfa; font-family: 'Courier New', monospace; font-size: 0.8rem; font-weight: bold; }
        .generate-btn { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); }
        .generate-btn:hover { background: linear-gradient(135deg, #5b21b6 0%, #7c3aed 100%); }
        .compact-section { background: #1e293b; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.75rem; }
    </style>
</head>
<body>
    <div class="container mx-auto p-4 max-w-7xl">
        <header class="text-center mb-4">
            <h1 class="text-2xl md:text-3xl font-bold text-white">Enhanced TTRPG World Generator</h1>
            <p class="text-sm text-gray-400 mt-1">Advanced terrain algorithms and Eryxian universe templates</p>
        </header>

        <div class="border-b border-gray-600 mb-4">
            <nav class="flex flex-wrap -mb-px" id="tabs">
                <button class="tab active" data-tab="terrain">Advanced Terrain</button>
                <button class="tab" data-tab="poi">POI Sandbox</button>
                <button class="tab" data-tab="starmap">Starmap</button>
                <button class="tab" data-tab="labyrinth">Labyrinth</button>
            </nav>
        </div>

        <div id="tab-contents">
            <!-- Advanced Terrain Generator -->
            <div id="terrain-content" class="tab-content active gap-4">
                <div class="w-full lg:w-1/3 space-y-3">
                    <div class="control-panel p-4 rounded-lg">
                        <h2 class="text-lg font-bold text-white mb-3">World Templates</h2>
                        <div id="world-templates" class="space-y-2">
                            <div class="template-card selected" data-template="custom">
                                <h4 class="font-medium text-white text-sm">Custom World</h4>
                                <p class="text-xs text-gray-400">Build your own terrain</p>
                            </div>
                            <div class="template-card" data-template="eryxia">
                                <h4 class="font-medium text-white text-sm">Eryxia</h4>
                                <p class="text-xs text-gray-400">Hyper-evolved jungles</p>
                            </div>
                            <div class="template-card" data-template="gordian">
                                <h4 class="font-medium text-white text-sm">Gordian Moon</h4>
                                <p class="text-xs text-gray-400">Ancient Worldship</p>
                            </div>
                            <div class="template-card" data-template="ionthara">
                                <h4 class="font-medium text-white text-sm">Ionthara</h4>
                                <p class="text-xs text-gray-400">Oceanic Super-Earth</p>
                            </div>
                        </div>
                    </div>

                    <div class="control-panel p-4 rounded-lg">
                        <h3 class="text-lg font-bold text-white mb-3">Generation</h3>
                        <div class="param-group">
                            <label for="terrain-algorithm">Algorithm</label>
                            <select id="terrain-algorithm" class="mb-2">
                                <option value="perlin">Perlin Noise</option>
                                <option value="cellular">Cellular Automata</option>
                                <option value="diamond-square">Diamond Square</option>
                                <option value="ridged">Ridged Noise</option>
                                <option value="voronoi">Voronoi Regions</option>
                            </select>
                        </div>
                        <div id="terrain-params" class="space-y-2"></div>
                        <button id="terrain-generate" class="w-full generate-btn text-white font-bold py-2 px-4 rounded-lg mt-3">Generate Terrain</button>
                    </div>

                    <div class="control-panel p-4 rounded-lg">
                        <h3 class="text-lg font-bold text-white mb-3">Layers</h3>
                        <div class="layer-toggle">
                            <span>Terrain</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="layer-terrain" checked>
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                        <div class="layer-toggle">
                            <span>POIs</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="layer-pois" checked>
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                        <div class="layer-toggle">
                            <span>Roads</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="layer-roads">
                                <span class="slider-toggle"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="w-full lg:w-2/3">
                    <div class="compact-section">
                        <canvas id="terrain-canvas" class="w-full aspect-square max-w-lg mx-auto"></canvas>
                        <div id="terrain-legend" class="mt-3 grid grid-cols-3 md:grid-cols-5 gap-2 text-xs"></div>
                    </div>
                    <div id="terrain-info" class="compact-section">
                        <h3 class="font-semibold text-white mb-2">Algorithm Info</h3>
                        <p class="text-sm text-gray-300" id="algorithm-description">Select an algorithm to see details</p>
                    </div>
                </div>
            </div>

            <!-- POI Sandbox -->
            <div id="poi-content" class="tab-content gap-4">
                <div class="w-full lg:w-1/3 space-y-3">
                    <div class="control-panel p-4 rounded-lg">
                        <h2 class="text-lg font-bold text-white mb-3">POI Controls</h2>
                        <div class="param-group">
                            <label for="poi-algorithm">Algorithm</label>
                            <select id="poi-algorithm">
                                <option value="random">Random</option>
                                <option value="poisson">Poisson Disc</option>
                                <option value="clusters">Clusters</option>
                                <option value="voronoi">Voronoi</option>
                            </select>
                        </div>
                        <div id="poi-params" class="space-y-2"></div>
                        <button id="poi-generate" class="w-full generate-btn text-white font-bold py-2 px-4 rounded-lg mt-3">Generate POIs</button>
                    </div>
                </div>
                <div class="w-full lg:w-2/3">
                    <div class="compact-section">
                        <canvas id="poi-canvas" class="w-full aspect-square max-w-lg mx-auto"></canvas>
                        <div id="poi-legend" class="mt-3 grid grid-cols-3 md:grid-cols-5 gap-2 text-xs"></div>
                    </div>
                </div>
            </div>

            <!-- Starmap -->
            <div id="starmap-content" class="tab-content gap-4">
                <div class="w-full lg:w-1/3 space-y-3">
                    <div class="control-panel p-4 rounded-lg">
                        <h2 class="text-lg font-bold text-white mb-3">Starmap Controls</h2>
                        <div class="param-group">
                            <label for="star-count">Star Count: <span id="star-count-value" class="value-display">150</span></label>
                            <input type="range" id="star-count" min="50" max="500" value="150">
                        </div>
                        <button id="starmap-generate" class="w-full generate-btn text-white font-bold py-2 px-4 rounded-lg mt-3">Generate Stars</button>
                    </div>
                </div>
                <div class="w-full lg:w-2/3">
                    <div class="compact-section">
                        <canvas id="starmap-canvas" class="w-full aspect-square max-w-lg mx-auto"></canvas>
                    </div>
                </div>
            </div>

            <!-- Labyrinth -->
            <div id="labyrinth-content" class="tab-content gap-4">
                <div class="w-full lg:w-1/3 space-y-3">
                    <div class="control-panel p-4 rounded-lg">
                        <h2 class="text-lg font-bold text-white mb-3">Labyrinth Controls</h2>
                        <div class="param-group">
                            <label for="lab-size">Size: <span id="lab-size-value" class="value-display">25</span></label>
                            <input type="range" id="lab-size" min="10" max="40" value="25">
                        </div>
                        <div class="param-group">
                            <label for="lab-pois">POIs: <span id="lab-pois-value" class="value-display">5</span></label>
                            <input type="range" id="lab-pois" min="0" max="15" value="5">
                        </div>
                        <button id="lab-generate" class="w-full generate-btn text-white font-bold py-2 px-4 rounded-lg mt-3">Generate Maze</button>
                    </div>
                </div>
                <div class="w-full lg:w-2/3">
                    <div class="compact-section">
                        <canvas id="lab-canvas" class="w-full aspect-square max-w-lg mx-auto"></canvas>
                        <div id="lab-legend" class="mt-3 grid grid-cols-3 md:grid-cols-5 gap-2 text-xs"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentTab = 'terrain';
        let currentTemplate = 'custom';
        let canvasSize = 512;
        
        // Shared POI types
        const POI_TYPES = {
            settlement: { name: 'Settlement', color: '#3b82f6', shape: 'square' },
            resource: { name: 'Resource', color: '#22c55e', shape: 'diamond' },
            danger: { name: 'Danger', color: '#ef4444', shape: 'triangle' },
            landmark: { name: 'Landmark', color: '#eab308', shape: 'star' },
            quest: { name: 'Quest', color: '#a855f7', shape: 'pentagon' }
        };

        // World templates
        const WORLD_TEMPLATES = {
            custom: {
                name: "Custom World",
                biomes: ['water', 'plains', 'forest', 'mountains'],
                colors: { water: '#1e40af', plains: '#22c55e', forest: '#15803d', mountains: '#78716c' }
            },
            eryxia: {
                name: "Eryxia",
                biomes: ['oceanic_depths', 'hyperjungle', 'scorched_plains', 'aerial_zones'],
                colors: { oceanic_depths: '#1e3a8a', hyperjungle: '#15803d', scorched_plains: '#dc2626', aerial_zones: '#0ea5e9' }
            },
            gordian: {
                name: "Gordian Moon",
                biomes: ['methane_seas', 'crystal_cities', 'geothermal_vents', 'polar_ice'],
                colors: { methane_seas: '#374151', crystal_cities: '#3b82f6', geothermal_vents: '#dc2626', polar_ice: '#f3f4f6' }
            },
            ionthara: {
                name: "Ionthara",
                biomes: ['surface_platforms', 'mid_zones', 'abyssal_depths', 'pressure_rifts'],
                colors: { surface_platforms: '#0ea5e9', mid_zones: '#1d4ed8', abyssal_depths: '#1e1b4b', pressure_rifts: '#7c3aed' }
            }
        };

        // Utility functions
        function seededRandom(seed) {
            let hash = 0;
            if (seed.length === 0) return hash;
            for (let i = 0; i < seed.length; i++) {
                const char = seed.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            const x = Math.sin(hash) * 10000;
            return x - Math.floor(x);
        }

        // Simple noise function
        function noise(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (n - Math.floor(n));
        }

        // Generate height using Perlin-like noise
        function generateHeight(x, y, scale, octaves) {
            let height = 0;
            let amplitude = 1;
            let frequency = scale;
            
            for (let i = 0; i < octaves; i++) {
                height += noise(x * frequency, y * frequency) * amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return height / 2;
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            setupTabs();
            setupTerrainGenerator();
            setupPOIGenerator();
            setupStarmapGenerator();
            setupLabyrinthGenerator();
            
            // Initialize terrain tab
            generateTerrain();
        });

        function setupTabs() {
            document.getElementById('tabs').addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    // Update active tab
                    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    
                    e.target.classList.add('active');
                    currentTab = e.target.dataset.tab;
                    document.getElementById(currentTab + '-content').classList.add('active');
                }
            });
        }

        // Terrain Generator
        function setupTerrainGenerator() {
            const canvas = document.getElementById('terrain-canvas');
            const ctx = canvas.getContext('2d');
            const algorithmSelect = document.getElementById('terrain-algorithm');
            const generateBtn = document.getElementById('terrain-generate');
            const paramsContainer = document.getElementById('terrain-params');
            const infoContainer = document.getElementById('algorithm-description');
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;

            const algorithms = {
                perlin: {
                    name: "Perlin Noise",
                    description: "Creates natural-looking terrain with rolling hills and organic shapes",
                    params: `
                        <div class="param-group">
                            <label for="perlin-scale">Scale: <span id="perlin-scale-value" class="value-display">0.01</span></label>
                            <input type="range" id="perlin-scale" min="0.005" max="0.05" step="0.005" value="0.01">
                        </div>
                        <div class="param-group">
                            <label for="perlin-octaves">Octaves: <span id="perlin-octaves-value" class="value-display">4</span></label>
                            <input type="range" id="perlin-octaves" min="1" max="8" value="4">
                        </div>
                    `,
                    generate: function() {
                        const scale = parseFloat(document.getElementById('perlin-scale').value);
                        const octaves = parseInt(document.getElementById('perlin-octaves').value);
                        const heightMap = [];
                        
                        for (let y = 0; y < canvasSize; y++) {
                            heightMap[y] = [];
                            for (let x = 0; x < canvasSize; x++) {
                                heightMap[y][x] = generateHeight(x, y, scale, octaves);
                            }
                        }
                        return heightMap;
                    }
                },
                cellular: {
                    name: "Cellular Automata",
                    description: "Creates cave-like structures and organic formations",
                    params: `
                        <div class="param-group">
                            <label for="cellular-density">Density: <span id="cellular-density-value" class="value-display">45</span>%</label>
                            <input type="range" id="cellular-density" min="20" max="70" value="45">
                        </div>
                        <div class="param-group">
                            <label for="cellular-iterations">Iterations: <span id="cellular-iterations-value" class="value-display">5</span></label>
                            <input type="range" id="cellular-iterations" min="1" max="10" value="5">
                        </div>
                    `,
                    generate: function() {
                        const density = parseFloat(document.getElementById('cellular-density').value) / 100;
                        const iterations = parseInt(document.getElementById('cellular-iterations').value);
                        let map = [];
                        
                        // Initialize random map
                        for (let y = 0; y < canvasSize; y++) {
                            map[y] = [];
                            for (let x = 0; x < canvasSize; x++) {
                                map[y][x] = Math.random() < density ? 1 : 0;
                            }
                        }
                        
                        // Apply cellular automata rules
                        for (let iter = 0; iter < iterations; iter++) {
                            const newMap = [];
                            for (let y = 0; y < canvasSize; y++) {
                                newMap[y] = [];
                                for (let x = 0; x < canvasSize; x++) {
                                    let neighbors = 0;
                                    for (let dy = -1; dy <= 1; dy++) {
                                        for (let dx = -1; dx <= 1; dx++) {
                                            const ny = y + dy;
                                            const nx = x + dx;
                                            if (ny >= 0 && ny < canvasSize && nx >= 0 && nx < canvasSize) {
                                                neighbors += map[ny][nx];
                                            } else {
                                                neighbors += 1; // Treat boundaries as walls
                                            }
                                        }
                                    }
                                    newMap[y][x] = neighbors >= 5 ? 1 : 0;
                                }
                            }
                            map = newMap;
                        }
                        
                        return map;
                    }
                },
                "diamond-square": {
                    name: "Diamond Square",
                    description: "Creates fractal terrain with mountain-like features",
                    params: `
                        <div class="param-group">
                            <label for="ds-roughness">Roughness: <span id="ds-roughness-value" class="value-display">0.5</span></label>
                            <input type="range" id="ds-roughness" min="0.1" max="2.0" step="0.1" value="0.5">
                        </div>
                    `,
                    generate: function() {
                        const roughness = parseFloat(document.getElementById('ds-roughness').value);
                        const size = 256; // Use power of 2 for diamond-square
                        const map = Array(size + 1).fill().map(() => Array(size + 1).fill(0));
                        
                        // Initialize corners
                        map[0][0] = Math.random();
                        map[0][size] = Math.random();
                        map[size][0] = Math.random();
                        map[size][size] = Math.random();
                        
                        let step = size;
                        while (step > 1) {
                            const half = step / 2;
                            
                            // Diamond step
                            for (let y = half; y < size; y += step) {
                                for (let x = half; x < size; x += step) {
                                    const avg = (map[y - half][x - half] + map[y - half][x + half] +
                                                map[y + half][x - half] + map[y + half][x + half]) / 4;
                                    map[y][x] = avg + (Math.random() - 0.5) * roughness;
                                }
                            }
                            
                            // Square step
                            for (let y = 0; y <= size; y += half) {
                                for (let x = (y + half) % step; x <= size; x += step) {
                                    let sum = 0, count = 0;
                                    if (y - half >= 0) { sum += map[y - half][x]; count++; }
                                    if (y + half <= size) { sum += map[y + half][x]; count++; }
                                    if (x - half >= 0) { sum += map[y][x - half]; count++; }
                                    if (x + half <= size) { sum += map[y][x + half]; count++; }
                                    
                                    if (count > 0) {
                                        map[y][x] = sum / count + (Math.random() - 0.5) * roughness;
                                    }
                                }
                            }
                            
                            step /= 2;
                            roughness *= 0.5;
                        }
                        
                        // Scale to canvas size
                        const scaledMap = [];
                        for (let y = 0; y < canvasSize; y++) {
                            scaledMap[y] = [];
                            for (let x = 0; x < canvasSize; x++) {
                                const sx = Math.floor(x * size / canvasSize);
                                const sy = Math.floor(y * size / canvasSize);
                                scaledMap[y][x] = Math.max(0, Math.min(1, map[sy][sx]));
                            }
                        }
                        
                        return scaledMap;
                    }
                },
                ridged: {
                    name: "Ridged Noise",
                    description: "Creates sharp ridges and dramatic mountain features",
                    params: `
                        <div class="param-group">
                            <label for="ridged-scale">Scale: <span id="ridged-scale-value" class="value-display">0.02</span></label>
                            <input type="range" id="ridged-scale" min="0.01" max="0.05" step="0.005" value="0.02">
                        </div>
                    `,
                    generate: function() {
                        const scale = parseFloat(document.getElementById('ridged-scale').value);
                        const heightMap = [];
                        
                        for (let y = 0; y < canvasSize; y++) {
                            heightMap[y] = [];
                            for (let x = 0; x < canvasSize; x++) {
                                let height = Math.abs(noise(x * scale, y * scale));
                                height = 1 - height; // Invert for ridges
                                height = height * height; // Square for sharpness
                                heightMap[y][x] = height;
                            }
                        }
                        return heightMap;
                    }
                },
                voronoi: {
                    name: "Voronoi Regions",
                    description: "Creates distinct territorial regions",
                    params: `
                        <div class="param-group">
                            <label for="voronoi-seeds">Seeds: <span id="voronoi-seeds-value" class="value-display">20</span></label>
                            <input type="range" id="voronoi-seeds" min="5" max="50" value="20">
                        </div>
                    `,
                    generate: function() {
                        const numSeeds = parseInt(document.getElementById('voronoi-seeds').value);
                        const seeds = [];
                        
                        // Generate random seed points
                        for (let i = 0; i < numSeeds; i++) {
                            seeds.push({
                                x: Math.random() * canvasSize,
                                y: Math.random() * canvasSize,
                                height: Math.random()
                            });
                        }
                        
                        const heightMap = [];
                        for (let y = 0; y < canvasSize; y++) {
                            heightMap[y] = [];
                            for (let x = 0; x < canvasSize; x++) {
                                let closestDist = Infinity;
                                let closestHeight = 0;
                                
                                for (const seed of seeds) {
                                    const dist = Math.sqrt((x - seed.x) ** 2 + (y - seed.y) ** 2);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closestHeight = seed.height;
                                    }
                                }
                                
                                heightMap[y][x] = closestHeight;
                            }
                        }
                        
                        return heightMap;
                    }
                }
            };

            function updateTerrainParams() {
                const selectedAlgo = algorithmSelect.value;
                const algo = algorithms[selectedAlgo];
                paramsContainer.innerHTML = algo.params;
                infoContainer.textContent = algo.description;
                
                // Add event listeners for parameter updates
                paramsContainer.querySelectorAll('input[type="range"]').forEach(slider => {
                    const valueSpan = document.getElementById(slider.id + '-value');
                    if (valueSpan) {
                        slider.addEventListener('input', function() {
                            valueSpan.textContent = slider.value;
                        });
                    }
                });
            }

            // Template selection
            document.getElementById('world-templates').addEventListener('click', function(e) {
                const card = e.target.closest('.template-card');
                if (card) {
                    document.querySelectorAll('.template-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    currentTemplate = card.dataset.template;
                }
            });

            algorithmSelect.addEventListener('change', updateTerrainParams);
            generateBtn.addEventListener('click', generateTerrain);
            
            updateTerrainParams();
        }

        function generateTerrain() {
            const canvas = document.getElementById('terrain-canvas');
            const ctx = canvas.getContext('2d');
            const algorithmSelect = document.getElementById('terrain-algorithm');
            const selectedAlgo = algorithmSelect.value;
            
            // Get algorithm
            const algorithms = {
                perlin: document.querySelector('[data-tab="terrain"]').algorithms?.perlin,
                cellular: document.querySelector('[data-tab="terrain"]').algorithms?.cellular,
                "diamond-square": document.querySelector('[data-tab="terrain"]').algorithms?.["diamond-square"],
                ridged: document.querySelector('[data-tab="terrain"]').algorithms?.ridged,
                voronoi: document.querySelector('[data-tab="terrain"]').algorithms?.voronoi
            };

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Generate terrain based on selected algorithm
            let heightMap;
            if (selectedAlgo === 'perlin') {
                const scale = parseFloat(document.getElementById('perlin-scale')?.value || 0.01);
                const octaves = parseInt(document.getElementById('perlin-octaves')?.value || 4);
                heightMap = [];
                for (let y = 0; y < canvasSize; y++) {
                    heightMap[y] = [];
                    for (let x = 0; x < canvasSize; x++) {
                        heightMap[y][x] = generateHeight(x, y, scale, octaves);
                    }
                }
            } else if (selectedAlgo === 'cellular') {
                const density = parseFloat(document.getElementById('cellular-density')?.value || 45) / 100;
                const iterations = parseInt(document.getElementById('cellular-iterations')?.value || 5);
                let map = [];
                
                // Initialize
                for (let y = 0; y < canvasSize; y++) {
                    map[y] = [];
                    for (let x = 0; x < canvasSize; x++) {
                        map[y][x] = Math.random() < density ? 1 : 0;
                    }
                }
                
                // Apply cellular automata
                for (let iter = 0; iter < iterations; iter++) {
                    const newMap = [];
                    for (let y = 0; y < canvasSize; y++) {
                        newMap[y] = [];
                        for (let x = 0; x < canvasSize; x++) {
                            let neighbors = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < canvasSize && nx >= 0 && nx < canvasSize) {
                                        neighbors += map[ny][nx];
                                    } else {
                                        neighbors += 1;
                                    }
                                }
                            }
                            newMap[y][x] = neighbors >= 5 ? 1 : 0;
                        }
                    }
                    map = newMap;
                }
                heightMap = map;
            } else {
                // Default simple noise
                heightMap = [];
                for (let y = 0; y < canvasSize; y++) {
                    heightMap[y] = [];
                    for (let x = 0; x < canvasSize; x++) {
                        heightMap[y][x] = Math.random();
                    }
                }
            }
            
            // Draw terrain
            drawTerrain(ctx, heightMap);
            
            // Generate and draw POIs if enabled
            if (document.getElementById('layer-pois').checked) {
                const pois = generateTerrainPOIs(heightMap);
                drawPOIs(ctx, pois);
            }
            
            updateTerrainLegend();
        }

        function drawTerrain(ctx, heightMap) {
            const imageData = ctx.createImageData(canvasSize, canvasSize);
            const template = WORLD_TEMPLATES[currentTemplate];
            const colors = template.colors;
            const colorKeys = Object.keys(colors);
            
            for (let y = 0; y < canvasSize; y++) {
                for (let x = 0; x < canvasSize; x++) {
                    const height = heightMap[y] ? heightMap[y][x] || 0 : 0;
                    const normalizedHeight = Math.max(0, Math.min(1, height));
                    
                    // Map height to biome
                    const biomeIndex = Math.floor(normalizedHeight * colorKeys.length);
                    const colorKey = colorKeys[Math.min(biomeIndex, colorKeys.length - 1)];
                    const color = colors[colorKey];
                    
                    // Convert hex to RGB
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    
                    const index = (y * canvasSize + x) * 4;
                    imageData.data[index] = r;
                    imageData.data[index + 1] = g;
                    imageData.data[index + 2] = b;
                    imageData.data[index + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function generateTerrainPOIs(heightMap) {
            const pois = [];
            const poiKeys = Object.keys(POI_TYPES);
            const numPOIs = 30;
            
            for (let i = 0; i < numPOIs; i++) {
                const x = Math.floor(Math.random() * canvasSize);
                const y = Math.floor(Math.random() * canvasSize);
                const height = heightMap[y] ? heightMap[y][x] || 0 : 0;
                
                // Only place POIs on land (height > 0.3)
                if (height > 0.3) {
                    pois.push({
                        x: x,
                        y: y,
                        type: poiKeys[Math.floor(Math.random() * poiKeys.length)]
                    });
                }
            }
            
            return pois;
        }

        function drawPOIs(ctx, pois) {
            pois.forEach(poi => {
                const type = POI_TYPES[poi.type];
                if (!type) return;
                
                ctx.fillStyle = type.color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                
                const size = 4;
                
                switch (type.shape) {
                    case 'square':
                        ctx.fillRect(poi.x - size/2, poi.y - size/2, size, size);
                        ctx.strokeRect(poi.x - size/2, poi.y - size/2, size, size);
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(poi.x, poi.y - size/2);
                        ctx.lineTo(poi.x - size/2, poi.y + size/2);
                        ctx.lineTo(poi.x + size/2, poi.y + size/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 'diamond':
                        ctx.beginPath();
                        ctx.moveTo(poi.x, poi.y - size/2);
                        ctx.lineTo(poi.x + size/2, poi.y);
                        ctx.lineTo(poi.x, poi.y + size/2);
                        ctx.lineTo(poi.x - size/2, poi.y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 'star':
                        drawStar(ctx, poi.x, poi.y, 5, size/2, size/4);
                        break;
                    case 'pentagon':
                        drawPolygon(ctx, poi.x, poi.y, 5, size/2);
                        break;
                    default:
                        ctx.beginPath();
                        ctx.arc(poi.x, poi.y, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                }
            });
        }

        function drawStar(ctx, x, y, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(x, y - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
                rot += step;
                ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
                rot += step;
            }
            
            ctx.lineTo(x, y - outerRadius);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawPolygon(ctx, x, y, sides, radius) {
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides;
                const px = x + radius * Math.cos(angle);
                const py = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function updateTerrainLegend() {
            const legend = document.getElementById('terrain-legend');
            const template = WORLD_TEMPLATES[currentTemplate];
            legend.innerHTML = '';
            
            Object.entries(template.colors).forEach(([biome, color]) => {
                legend.innerHTML += `
                    <div class="flex items-center gap-1">
                        <div style="width: 10px; height: 10px; background-color: ${color}; border-radius: 2px;"></div>
                        <span>${biome.replace('_', ' ')}</span>
                    </div>
                `;
            });
            
            if (document.getElementById('layer-pois').checked) {
                Object.values(POI_TYPES).forEach(type => {
                    legend.innerHTML += `
                        <div class="flex items-center gap-1">
                            <div style="width: 10px; height: 10px; background-color: ${type.color}; border-radius: 2px;"></div>
                            <span>${type.name}</span>
                        </div>
                    `;
                });
            }
        }

        // POI Generator (simplified)
        function setupPOIGenerator() {
            const canvas = document.getElementById('poi-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            document.getElementById('poi-generate').addEventListener('click', function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const algorithm = document.getElementById('poi-algorithm').value;
                let points = [];
                
                if (algorithm === 'random') {
                    for (let i = 0; i < 100; i++) {
                        points.push({
                            x: Math.random() * canvasSize,
                            y: Math.random() * canvasSize,
                            type: Object.keys(POI_TYPES)[Math.floor(Math.random() * Object.keys(POI_TYPES).length)]
                        });
                    }
                } else {
                    // Simplified other algorithms
                    for (let i = 0; i < 50; i++) {
                        points.push({
                            x: Math.random() * canvasSize,
                            y: Math.random() * canvasSize,
                            type: Object.keys(POI_TYPES)[Math.floor(Math.random() * Object.keys(POI_TYPES).length)]
                        });
                    }
                }
                
                drawPOIs(ctx, points);
            });
        }

        // Starmap Generator (simplified)
        function setupStarmapGenerator() {
            const canvas = document.getElementById('starmap-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            document.getElementById('star-count').addEventListener('input', function() {
                document.getElementById('star-count-value').textContent = this.value;
            });
            
            document.getElementById('starmap-generate').addEventListener('click', function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000011';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const count = parseInt(document.getElementById('star-count').value);
                
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * canvasSize;
                    const y = Math.random() * canvasSize;
                    const radius = Math.random() * 2 + 0.5;
                    const brightness = Math.random() * 0.8 + 0.2;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = radius * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        // Labyrinth Generator (simplified)
        function setupLabyrinthGenerator() {
            const canvas = document.getElementById('lab-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            document.getElementById('lab-size').addEventListener('input', function() {
                document.getElementById('lab-size-value').textContent = this.value;
            });
            
            document.getElementById('lab-pois').addEventListener('input', function() {
                document.getElementById('lab-pois-value').textContent = this.value;
            });
            
            document.getElementById('lab-generate').addEventListener('click', function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const size = parseInt(document.getElementById('lab-size').value);
                const cellSize = canvasSize / size;
                
                // Draw simple maze
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const px = x * cellSize;
                        const py = y * cellSize;
                        
                        // Randomly remove walls to create paths
                        if (Math.random() > 0.3) {
                            ctx.strokeRect(px, py, cellSize, cellSize);
                        }
                    }
                }
                
                // Add entrance and exit
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(cellSize * 0.25, cellSize * 0.25, cellSize * 0.5, cellSize * 0.5);
                
                ctx.fillStyle = '#ef4444';
                ctx.fillRect((size - 1) * cellSize + cellSize * 0.25, (size - 1) * cellSize + cellSize * 0.25, cellSize * 0.5, cellSize * 0.5);
            });
        }
    </script>
</body>
</html>