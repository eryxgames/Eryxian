<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eryxian Labyrinth Research Interface v6.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); }
        .glass-effect { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(12px); border: 1px solid rgba(75, 85, 99, 0.3); }
        .main-tab { transition: all 0.3s ease; border-bottom: 2px solid transparent; }
        .main-tab.active { border-bottom-color: #818cf8; color: #e0e7ff; text-shadow: 0 0 8px rgba(129, 140, 248, 0.5); }
        .info-box h3, .artifact-details h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: #c7d2fe; border-bottom: 1px solid #4a5568; padding-bottom: 0.5rem; text-shadow: 0 0 10px rgba(199, 210, 254, 0.3); }
        .info-box h4, .artifact-details h4 { font-size: 0.875rem; font-weight: 700; color: #a5b4fc; margin-top: 1rem; margin-bottom: 0.25rem; }
        .info-box p, .info-box li, .artifact-details p { font-size: 0.875rem; line-height: 1.6; }
        .info-box ul { list-style-type: '‚Ä∫ '; padding-left: 1rem; margin-bottom: 1rem; }
        .schematic-btn, .artifact-btn { transition: all 0.3s ease; background-color: rgba(75, 85, 99, 0.3); }
        .schematic-btn:hover, .artifact-btn:hover { background-color: rgba(99, 102, 241, 0.3); }
        .schematic-btn.active, .artifact-btn.active { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; box-shadow: 0 8px 15px -8px rgba(79, 70, 229, 0.5); transform: translateY(-1px); }
        .gm-output, .simulation-window { background: rgba(17, 24, 39, 0.8); backdrop-filter: blur(8px); border: 1px solid rgba(55, 65, 81, 0.5); transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(79, 70, 229, 0.6); }
        .btn-secondary { background-color: rgba(75, 85, 99, 0.4); border: 1px solid rgba(129, 140, 248, 0.3); transition: all 0.3s ease; }
        .btn-secondary:hover { background-color: rgba(99, 102, 241, 0.3); }
        .threat-indicator { border-left: 4px solid; padding: 0.5rem 1rem; margin-top: 1rem; border-radius: 0 0.375rem 0.375rem 0; }
        .threat-low { border-color: #10b981; background: rgba(16, 185, 129, 0.1); }
        .threat-medium { border-color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
        .threat-high { border-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        .threat-extreme { border-color: #dc2626; background: rgba(220, 38, 38, 0.15); box-shadow: 0 0 20px rgba(220, 38, 38, 0.2); }
        .physics-warning { background: linear-gradient(45deg, #dc2626, #f59e0b); color: white; padding: 2px 8px; border-radius: 9999px; font-size: 0.7rem; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); animation: glow 2s ease-in-out infinite alternate; display: inline-block; }
        @keyframes glow { from { box-shadow: 0 0 5px rgba(220, 38, 38, 0.5); } to { box-shadow: 0 0 15px rgba(220, 38, 38, 0.8); } }
        .custom-select, .custom-checkbox, .search-input { background-color: rgba(31, 41, 55, 0.8); border: 1px solid #4a5568; }
        .sim-log { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
        .sim-log p { margin-bottom: 0.5rem; }
        .log-time { color: #6ee7b7; } .log-alert { color: #f87171; font-weight: bold; } .log-action { color: #facc15; } .log-info { color: #93c5fd; } .log-system { color: #a78bfa; font-style: italic; } .log-probe { color: #c4b5fd; }
        .logo { height: 4rem; width: auto; filter: drop-shadow(0 0 10px rgba(129, 140, 248, 0.6)); transition: all 0.3s ease; }
        .logo:hover { filter: drop-shadow(0 0 15px rgba(165, 180, 252, 0.8)); transform: scale(1.05); }
        .main-header-grid { position: relative; display: flex; justify-content: space-between; align-items: center; min-height: 4rem; }
        .header-column { flex: 1; }
        .artifact-list { max-height: 450px; }
        .artifact-details img { max-width: 100%; height: auto; margin-top: 1rem; border-radius: 0.5rem; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); }
        #schematic-svg { cursor: pointer; }
        @media (min-width: 768px) { .logo-glow { position: absolute; left: 50%; transform: translateX(-50%); width: auto; } }
        @media (max-width: 767px) { .main-header-grid { flex-direction: column; gap: 1rem; } .header-column { flex-basis: auto; text-align: center !important; } .header-column a { justify-content: center; } }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-7xl glass-effect rounded-2xl shadow-2xl p-4 sm:p-6 lg:p-8">
        <header class="mb-6">
            <div class="main-header-grid mb-4 flex-wrap">
                <div class="text-left header-column">
                    <a href="https://eryxian.com" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm transition-colors duration-200 flex items-center gap-1">üåê Eryxian.com</a>
                    <a href="https://github.com/eryxgames/Eryxian/wiki" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm transition-colors duration-200 flex items-center gap-1 mt-1">üìö Universe Wiki</a>
                </div>
                <div class="logo-glow order-first md:order-none">
                    <img src="https://raw.githubusercontent.com/eryxgames/Eryxian/main/eryxian-dash-logo-sm.png" alt="Eryxian Research Interface" class="logo">
                </div>
                <div class="text-right header-column">
                    <a href="https://github.com/eryxgames/Eryxian/wiki/Eryxian-Labyrinths" target="_blank" class="text-purple-400 hover:text-purple-300 text-sm transition-colors duration-200 flex items-center gap-1 justify-end">üî¨ Labyrinths Research</a>
                </div>
            </div>
            <div class="text-center">
                <h1 class="text-3xl sm:text-4xl font-bold text-white mb-2 bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 bg-clip-text text-transparent">Eryxian Labyrinth Research Interface</h1>
                <p class="text-sm sm:text-base text-gray-400 mt-2">Field Anomaly Classification & GM Toolkit v6.0</p>
            </div>
        </header>

        <div class="border-b border-gray-700 mb-6">
            <nav class="flex justify-center -mb-px space-x-4 sm:space-x-8">
                <button data-tab="viewer" class="main-tab active text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Classification Viewer</button>
                <button data-tab="database" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Artifact Database</button>
                <button data-tab="generator" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">GM Toolkit</button>
                <button data-tab="simulator" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Interactive Simulation</button>
            </nav>
        </div>

        <div id="content-viewer" class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 glass-effect rounded-xl flex items-center justify-center p-4 min-h-[400px] lg:min-h-[500px] overflow-hidden">
                <svg id="schematic-svg" class="w-full h-full" viewBox="0 0 500 400"></svg>
            </div>
            <div class="glass-effect rounded-xl p-6">
                 <div class="flex items-center gap-2 mb-4">
                    <input type="checkbox" id="wiki-sync-viewer" class="wiki-sync-checkbox custom-checkbox w-4 h-4 rounded">
                    <label for="wiki-sync-viewer" class="wiki-sync-label text-sm text-gray-400">Sync with Live Wiki Data</label>
                </div>
                <div id="schematic-buttons" class="grid grid-cols-2 gap-2 mb-4"></div>
                <div id="info-panel" class="info-box max-h-[420px] overflow-y-auto pr-2"></div>
            </div>
        </div>

        <div id="content-database" class="hidden grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1 glass-effect rounded-xl p-4">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Artifact Catalog</h3>
                <input type="text" id="artifact-search" class="search-input w-full p-2 rounded-md mb-2 text-sm" placeholder="Search artifacts...">
                <div id="artifact-list" class="artifact-list overflow-y-auto pr-2 space-y-2"></div>
            </div>
            <div id="artifact-details-container" class="md:col-span-2 glass-effect rounded-xl p-6 hidden">
                <div id="artifact-details" class="overflow-y-auto max-h-[500px] pr-2"></div>
            </div>
        </div>

        <div id="content-generator" class="hidden">
             <div class="gm-output rounded-lg p-6">
                <div class="flex justify-between items-start mb-4 flex-wrap gap-4">
                    <h3 class="text-lg font-semibold text-purple-300">Anomaly Generator & GM Tools</h3>
                    <div class="flex gap-4 items-center flex-wrap">
                        <div class="flex items-center gap-2">
                             <label for="location-select" class="text-sm font-medium text-gray-400">Location:</label>
                             <select id="location-select" class="custom-select text-sm rounded-md py-1 px-2">
                                 <option value="surface">Surface</option>
                                 <option value="orbital">Low Orbit</option>
                                 <option value="space">Deep Space</option>
                             </select>
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="wiki-sync-generator" class="wiki-sync-checkbox custom-checkbox w-4 h-4 rounded">
                            <label for="wiki-sync-generator" class="wiki-sync-label text-sm text-gray-400">Sync with Live Wiki Data</label>
                        </div>
                    </div>
                </div>
                <div class="flex justify-center gap-2 flex-wrap mb-6">
                    <button id="gm-brief" class="btn-primary text-white px-4 py-2 rounded-lg text-sm font-semibold">Generate Mission Brief</button>
                    <button id="gm-scenario" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Hook</button>
                    <button id="gm-threat" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Threat</button>
                    <button id="gm-evidence" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Evidence</button>
                </div>
                <div id="generator-output" class="text-sm text-gray-300 min-h-[250px] transition-all duration-300 bg-black/20 p-4 rounded-md">
                    Select a generator tool to begin...
                </div>
            </div>
        </div>
        
        <div id="content-simulator" class="hidden grid-cols-1 md:grid-cols-2 gap-6">
            <div class="simulation-window rounded-lg p-6">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Simulation: The Threshold Gate Paradox</h3>
                <p class="text-sm text-gray-400 mb-4">Investigating Incident Report: New Eden Settlement.</p>
                <div id="paradox-log" class="sim-log text-sm min-h-[200px] bg-black/30 p-4 rounded-md mb-4 overflow-y-auto max-h-[300px]"></div>
                <div id="paradox-choices" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
            <div class="simulation-window rounded-lg p-6">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Simulation: Labyrinth Probe Explorer</h3>
                <p class="text-sm text-gray-400 mb-4">Minimalist probe data feed from a generated anomaly.</p>
                <div id="probe-log" class="sim-log text-sm min-h-[200px] bg-black/30 p-4 rounded-md mb-4 overflow-y-auto max-h-[300px]"></div>
                <div id="probe-choices" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
        </div>
    </div>

    <!-- Footer Section -->
    <footer class="text-center text-xs text-gray-500 mt-8 pb-4 px-4">
        <p>Eryxian Universe Game World created by Daniel Sandner, Copyright ¬© 2025 (see licenses on the content repositories of the <a href="https://github.com/eryxgames" target="_blank" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Eryxian Open Project</a>).</p>
    </footer>

    <script>
        // --- DATA & CONFIG ---
        const WIKI_URL = 'https://raw.githubusercontent.com/wiki/eryxgames/Eryxian/Eryxian-Labyrinths-Research-Data.md';
        let liveLabyrinthTypes = {};
        let liveArtifacts = {};
        let currentLabyrinthTypes = {};
        let currentArtifacts = {};
        const randItem = (arr) => arr && arr.length > 0 ? arr[Math.floor(Math.random() * arr.length)] : null;
        let DOM = {};

// --- ENHANCED & VARIANT DRAWING FUNCTIONS ---

let activeSVGListeners = []; // Holds active listeners for easy removal

// Helper to add and track listeners
function addTrackedListener(target, event, handler) {
    target.addEventListener(event, handler);
    activeSVGListeners.push({ target, event, handler });
}

function clearSVG() {
    if (window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
    
    activeSVGListeners.forEach(({ target, event, handler }) => {
        target.removeEventListener(event, handler);
    });
    activeSVGListeners = [];

    if (DOM.svg) {
        DOM.svg.innerHTML = '';
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const glowFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        glowFilter.id = 'glow';
        glowFilter.innerHTML = `<feGaussianBlur stdDeviation="3.5" result="coloredBlur"></feGaussianBlur><feMerge><feMergeNode in="coloredBlur"></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge>`;
        defs.appendChild(glowFilter);
        DOM.svg.appendChild(defs);
    }
}

// --- Spatial Labyrinth Functions ---

function drawSpatial_Interactive() {
    clearSVG();
    const mainPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    mainPath.setAttribute('d', "M100 100 H400 V300 H100 L250 200 Z");
    mainPath.setAttribute('fill', `rgba(129, 140, 248, 0.1)`);
    mainPath.setAttribute('stroke', `rgba(199, 210, 254, 0.6)`);
    mainPath.setAttribute('stroke-width', '2');
    mainPath.setAttribute('stroke-linejoin', 'round');
    mainPath.style.filter = 'url(#glow)';
    DOM.svg.appendChild(mainPath);

    addTrackedListener(DOM.svg, 'mousemove', (e) => {
        const rect = DOM.svg.getBoundingClientRect();
        const viewBox = DOM.svg.viewBox.baseVal;
        const mouseX = (e.clientX - rect.left) * (viewBox.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (viewBox.height / rect.height);
        mainPath.setAttribute('d', `M100 100 H400 V300 H100 L${mouseX} ${mouseY} Z`);
    });
}

function drawSpatial_Variant1() { // Gravity Well
    clearSVG();
    const shapes = [];
    const initialPoints = [
        [{x:100,y:100}, {x:400,y:100}, {x:400,y:300}, {x:100,y:300}, {x:250, y:200}],
        [{x:150,y:150}, {x:350,y:150}, {x:350,y:250}, {x:150,y:250}]
    ];

    initialPoints.forEach((points, i) => {
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('fill', `rgba(129, 140, 248, ${0.1 - i*0.05})`);
        polygon.setAttribute('stroke', `rgba(199, 210, 254, ${0.6 - i*0.2})`);
        polygon.setAttribute('stroke-width', '2');
        DOM.svg.appendChild(polygon);
        shapes.push({ el: polygon, initial: points });
    });

    const updatePoints = (mx, my) => {
        shapes.forEach(shape => {
            const newPoints = shape.initial.map(p => {
                const dx = p.x - mx;
                const dy = p.y - my;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    const falloff = (150 - dist) / 150;
                    const strength = 50 * Math.pow(falloff, 2);
                    const angle = Math.atan2(dy, dx);
                    return { x: p.x + Math.cos(angle) * strength, y: p.y + Math.sin(angle) * strength };
                }
                return p;
            }).map(p => `${p.x},${p.y}`).join(' ');
            shape.el.setAttribute('points', newPoints);
        });
    };
    
    updatePoints(-999, -999);

    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        const viewBox = DOM.svg.viewBox.baseVal;
        const mouseX = (e.clientX - rect.left) * (viewBox.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (viewBox.height / rect.height);
        updatePoints(mouseX, mouseY);
    });
}

function drawSpatial_Variant2() { // Interactive Tesseract
    clearSVG();
    const size = 80;
    const center_x = 250, center_y = 200;
    let rotXW = 0, rotYW = 0;

    const vertices = [];
    for (let i = 0; i < 16; i++) {
        vertices.push({
            x: (i & 1 ? 1 : -1), y: (i & 2 ? 1 : -1),
            z: (i & 4 ? 1 : -1), w: (i & 8 ? 1 : -1)
        });
    }

    const edges = [
        [0,1],[0,2],[0,4],[0,8],[1,3],[1,5],[1,9],[2,3],[2,6],[2,10],[3,7],[3,11],
        [4,5],[4,6],[4,12],[5,7],[5,13],[6,7],[6,14],[7,15],[8,9],[8,10],[8,12],
        [9,11],[9,13],[10,11],[10,14],[11,15],[12,13],[12,14],[13,15],[14,15]
    ];
    
    const edgeElements = edges.map(() => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('stroke', 'rgba(199, 210, 254, 0.7)');
        line.setAttribute('stroke-width', '1.5');
        DOM.svg.appendChild(line);
        return line;
    });

    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        rotYW = ((e.clientX - rect.left) / rect.width - 0.5) * Math.PI;
        rotXW = ((e.clientY - rect.top) / rect.height - 0.5) * Math.PI;
    });

    function animate() {
        const angleXW = rotXW; const angleYW = rotYW;
        
        const projected = vertices.map(v => {
            // Rotate in 4D
            let x = v.x, y = v.y, z = v.z, w = v.w;
            let tempX, tempW, tempY;

            // Rotate on XW plane
            tempX = x * Math.cos(angleXW) - w * Math.sin(angleXW);
            tempW = x * Math.sin(angleXW) + w * Math.cos(angleXW);
            x = tempX; w = tempW;
            
            // Rotate on YW plane
            tempY = y * Math.cos(angleYW) - w * Math.sin(angleYW);
            tempW = y * Math.sin(angleYW) + w * Math.cos(angleYW);
            y = tempY; w = tempW;

            // Project 4D to 3D, then 3D to 2D
            const perspective = 1 / (3 - w);
            x *= perspective; y *= perspective; z *= perspective;
            
            return {
                x: x * size + center_x,
                y: y * size + center_y
            };
        });

        edges.forEach((edge, i) => {
            const p1 = projected[edge[0]];
            const p2 = projected[edge[1]];
            edgeElements[i].setAttribute('x1', p1.x); edgeElements[i].setAttribute('y1', p1.y);
            edgeElements[i].setAttribute('x2', p2.x); edgeElements[i].setAttribute('y2', p2.y);
        });

        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Variant3() { // Inverse Geometry Portal
    clearSVG();
    const portal = { x: 250, y: 200, r: 100 };
    const gridLines = [];

    // Create a grid of polylines
    for (let i = 0; i <= 10; i++) {
        // Horizontal
        const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        hLine.setAttribute('fill', 'none'); hLine.setAttribute('stroke', 'rgba(165, 180, 252, 0.3)'); hLine.setAttribute('stroke-width', '1');
        DOM.svg.appendChild(hLine);
        gridLines.push({ type: 'h', pos: i * 40, el: hLine, points: [] });

        // Vertical
        const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        vLine.setAttribute('fill', 'none'); vLine.setAttribute('stroke', 'rgba(165, 180, 252, 0.3)'); vLine.setAttribute('stroke-width', '1');
        DOM.svg.appendChild(vLine);
        gridLines.push({ type: 'v', pos: i * 50, el: vLine, points: [] });
    }

    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        const viewBox = DOM.svg.viewBox.baseVal;
        portal.x = (e.clientX - rect.left) * (viewBox.width / rect.width);
        portal.y = (e.clientY - rect.top) * (viewBox.height / rect.height);
        const dx = portal.x - 250; const dy = portal.y - 200;
        portal.r = 150 - Math.sqrt(dx*dx + dy*dy) * 0.5; // Radius shrinks as mouse moves away from center
    });

    let t = 0;
    function animate() {
        t += 0.01;
        const radius = portal.r * (1 + Math.sin(t) * 0.1);
        const r2 = radius * radius;
        
        gridLines.forEach(line => {
            let pointsStr = '';
            for (let i = 0; i <= 50; i++) {
                const p = {};
                if (line.type === 'h') { p.x = i * 10; p.y = line.pos; }
                else { p.x = line.pos; p.y = i * 8; }
                
                // Inverse transform
                const dx = p.x - portal.x;
                const dy = p.y - portal.y;
                const d2 = dx * dx + dy * dy;
                
                if (d2 === 0) continue; // Avoid division by zero at center
                const factor = r2 / d2;
                
                const finalX = portal.x + dx * factor;
                const finalY = portal.y + dy * factor;
                pointsStr += `${finalX},${finalY} `;
            }
            line.el.setAttribute('points', pointsStr);
        });
        
        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Master() {
    const variants = [drawSpatial_Interactive, drawSpatial_Variant1, drawSpatial_Variant2, drawSpatial_Variant3];
    randItem(variants)();
}

        // --- Temporal Labyrinth Functions ---

        function drawTemporal_Interactive() {
            clearSVG();
            const clockFace = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            clockFace.setAttribute('cx', '250'); clockFace.setAttribute('cy', '200'); clockFace.setAttribute('r', '150');
            clockFace.setAttribute('fill', 'rgba(165, 180, 252, 0.1)'); clockFace.setAttribute('stroke', '#a5b4fc'); clockFace.setAttribute('stroke-width', '1');
            DOM.svg.appendChild(clockFace);

            const hourHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hourHand.setAttribute('x1', '250'); hourHand.setAttribute('y1', '200'); hourHand.setAttribute('stroke', '#e0e7ff');
            hourHand.setAttribute('stroke-width', '6'); hourHand.setAttribute('stroke-linecap', 'round');
            DOM.svg.appendChild(hourHand);

            const minuteHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            minuteHand.setAttribute('x1', '250'); minuteHand.setAttribute('y1', '200'); minuteHand.setAttribute('stroke', '#c7d2fe');
            minuteHand.setAttribute('stroke-width', '4'); minuteHand.setAttribute('stroke-linecap', 'round');
            DOM.svg.appendChild(minuteHand);
            
            let time = 0;
            let timeWarpFactor = 0.01;

            addTrackedListener(DOM.svg, 'mousemove', (e) => {
                const rect = DOM.svg.getBoundingClientRect();
                timeWarpFactor = ((e.clientX - rect.left) / rect.width - 0.5) * 0.1;
            });

            addTrackedListener(DOM.svg, 'click', () => {
                time += Math.random() * 2 - 1; // Time jump
                clockFace.setAttribute('fill', 'rgba(239, 68, 68, 0.3)');
                setTimeout(() => clockFace.setAttribute('fill', 'rgba(165, 180, 252, 0.1)'), 100);
            });

            function animate() {
                time += timeWarpFactor;
                const hourAngle = (time * 0.5);
                const minuteAngle = (time * 2);
                hourHand.setAttribute('x2', 250 + 80 * Math.cos(hourAngle));
                hourHand.setAttribute('y2', 200 + 80 * Math.sin(hourAngle));
                minuteHand.setAttribute('x2', 250 + 120 * Math.cos(minuteAngle));
                minuteHand.setAttribute('y2', 200 + 120 * Math.sin(minuteAngle));
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        // --- Quantum Labyrinth Functions ---

        function drawQuantum_Interactive() {
            clearSVG();
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', '175'); box.setAttribute('y', '125'); box.setAttribute('width', '150'); box.setAttribute('height', '150');
            box.setAttribute('stroke', '#c7d2fe'); box.setAttribute('stroke-width', '2'); box.setAttribute('fill', 'rgba(129, 140, 248, 0.1)');
            DOM.svg.appendChild(box);

            const wavePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wavePath.setAttribute('fill', 'none'); wavePath.setAttribute('stroke', '#a5b4fc'); wavePath.setAttribute('stroke-width', '3');
            wavePath.style.filter = 'url(#glow)';
            DOM.svg.appendChild(wavePath);

            const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            particle.setAttribute('r', '6'); particle.setAttribute('fill', '#e0e7ff');
            DOM.svg.appendChild(particle);

            let t = 0;
            let isCollapsed = false;

            function animate() {
                if (isCollapsed) return;
                t += 0.02;
                const waveD = `M180 200 C 210 ${200 + Math.sin(t)*30}, 240 ${200 + Math.cos(t)*30}, 270 200 S 300 ${200 - Math.sin(t)*30}, 320 200`;
                wavePath.setAttribute('d', waveD);
                
                const particleX = 250 + Math.sin(t*1.5) * 60;
                const particleY = 200 + Math.cos(t*2) * 40;
                particle.setAttribute('cx', particleX);
                particle.setAttribute('cy', particleY);
                particle.style.opacity = 0.5 + Math.sin(t*3)*0.5;
                box.setAttribute('stroke-dasharray', `${5 + Math.sin(t)*4} ${5 - Math.sin(t)*4}`);
                window.animationFrameId = requestAnimationFrame(animate);
            }
            
            addTrackedListener(DOM.svg, 'click', () => {
                isCollapsed = !isCollapsed;
                if (isCollapsed) {
                    if(window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
                    wavePath.style.display = 'none';
                    particle.style.opacity = '1';
                    box.setAttribute('stroke-dasharray', 'none');
                } else {
                    wavePath.style.display = 'block';
                    animate();
                }
            });
            animate();
        }

        // --- Signal Labyrinth Functions ---

        function drawSignal_Interactive() {
            clearSVG();
            const head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            head.setAttribute('d', 'M200 200 Q 250 150 300 200 T 400 200 Q 350 250 300 200 T 200 200');
            head.setAttribute('fill', 'none'); head.setAttribute('stroke', '#e0e7ff'); head.setAttribute('stroke-width', '2');
            DOM.svg.appendChild(head);

            const dataStreams = [];
            for(let i=0; i<20; i++) {
                const stream = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                stream.setAttribute('fill', 'none');
                stream.setAttribute('stroke', `rgba(165, 180, 252, ${Math.random() * 0.5 + 0.3})`);
                stream.setAttribute('stroke-width', '1.5');
                DOM.svg.appendChild(stream);
                dataStreams.push({el: stream, offset: Math.random() * 100, speed: Math.random() * 10 + 15});
            }

            let t = 0;
            function animate() {
                t += 0.01;
                dataStreams.forEach(s => {
                    const startY = 50 + (s.offset + t * s.speed) % 300;
                    const midY1 = startY + Math.sin(t*2 + s.offset) * 20;
                    const midY2 = startY + Math.cos(t*2 + s.offset) * 20;
                    s.el.setAttribute('d', `M50 ${startY} C 150 ${midY1}, 350 ${midY2}, 450 ${startY}`);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawSignal_Variant1() { // DNA Helix & Data Rain
            clearSVG();
            const wave1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wave1.setAttribute('fill', 'none'); wave1.setAttribute('stroke', '#a5b4fc');
            DOM.svg.appendChild(wave1);
            
            const wave2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wave2.setAttribute('fill', 'none'); wave2.setAttribute('stroke', '#818cf8');
            DOM.svg.appendChild(wave2);

            const dataRain = [];
            for (let i = 0; i < 50; i++) {
                const particle = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const x = Math.random() * 500;
                const y = Math.random() * 400;
                particle.setAttribute('x1', x); particle.setAttribute('y1', y);
                particle.setAttribute('x2', x); particle.setAttribute('y2', y + 5);
                particle.setAttribute('stroke', '#4a5568'); particle.setAttribute('stroke-width', '1');
                DOM.svg.appendChild(particle);
                dataRain.push({ el: particle, x: x, y: y, speed: Math.random() * 2 + 1, corrupted: 0 });
            }

            let t = 0;
            function animate() {
                t += 0.02;
                let d1 = "M 50 200"; let d2 = "M 50 200";
                for (let x = 50; x <= 450; x += 5) {
                    const phase = (x / 100);
                    d1 += ` L ${x} ${200 + Math.sin(t + phase) * 60}`;
                    d2 += ` L ${x} ${200 + Math.sin(t + phase + Math.PI) * 60}`;
                }
                wave1.setAttribute('d', d1);
                wave2.setAttribute('d', d2);
                wave1.setAttribute('stroke-width', 3 + Math.cos(t*2) * 2);
                wave2.setAttribute('stroke-width', 3 - Math.cos(t*2) * 2);

                dataRain.forEach(p => {
                    p.y += p.speed;
                    if (p.y > 405) { p.y = -5; p.x = Math.random() * 500; }

                    const waveY1 = 200 + Math.sin(t + p.x/100) * 60;
                    if (Math.abs(p.y - waveY1) < 5 && p.corrupted <= 0) p.corrupted = 20;

                    if (p.corrupted > 0) {
                        p.el.setAttribute('stroke', '#ef4444');
                        p.corrupted--;
                    } else {
                        p.el.setAttribute('stroke', '#4a5568');
                    }
                    p.el.setAttribute('x1', p.x); p.el.setAttribute('y1', p.y);
                    p.el.setAttribute('x2', p.x); p.el.setAttribute('y2', p.y + 5);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawSignal_Master() {
            const variants = [drawSignal_Variant1, drawSignal_Variant1, drawSignal_Interactive];
            randItem(variants)();
        }


        // --- Thermo Labyrinth Functions ---

        function drawThermo_Variant1() { // Maxwell's Demon
            clearSVG();
            const particles = [];
            const container = { x: 50, y: 50, w: 400, h: 300 };

            for (let i = 0; i < 80; i++) {
                const isHot = i < 40;
                const p = {
                    x: container.x + Math.random() * container.w,
                    y: container.y + Math.random() * container.h,
                    vx: (Math.random() - 0.5) * (isHot ? 2 : 1),
                    vy: (Math.random() - 0.5) * (isHot ? 2 : 1),
                    isHot: isHot,
                    el: document.createElementNS('http://www.w3.org/2000/svg', 'circle')
                };
                p.el.setAttribute('r', isHot ? '3' : '4');
                p.el.setAttribute('fill', isHot ? '#f87171' : '#60a5fa');
                DOM.svg.appendChild(p.el);
                particles.push(p);
            }
            
            let isDrawing = false;
            let demonWall = [];
            const wallLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            wallLine.setAttribute('fill', 'none');
            wallLine.setAttribute('stroke', '#e0e7ff');
            wallLine.setAttribute('stroke-width', '2');
            wallLine.setAttribute('stroke-dasharray', '4 4');
            DOM.svg.appendChild(wallLine);

            addTrackedListener(DOM.svg, 'mousedown', e => {
                isDrawing = true;
                demonWall = [];
                wallLine.setAttribute('points', '');
            });

            addTrackedListener(DOM.svg, 'mousemove', e => {
                if (!isDrawing) return;
                const rect = DOM.svg.getBoundingClientRect();
                const viewBox = DOM.svg.viewBox.baseVal;
                const x = (e.clientX - rect.left) * (viewBox.width / rect.width);
                const y = (e.clientY - rect.top) * (viewBox.height / rect.height);
                demonWall.push({ x, y });
                wallLine.setAttribute('points', demonWall.map(p => `${p.x},${p.y}`).join(' '));
            });
            
            addTrackedListener(DOM.svg, 'mouseup', () => { isDrawing = false; });

            function animate() {
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < container.x + 3 || p.x > container.x + container.w - 3) p.vx *= -1;
                    if (p.y < container.y + 3 || p.y > container.y + container.h - 3) p.vy *= -1;

                    // Simple wall implementation: sort particles based on which side of the wall's start-Y they are
                    if (demonWall.length > 1) {
                        const wallY = demonWall[0].y;
                        if (p.isHot && p.y > wallY) p.vy -= 0.1; // Hot particle below wall, push up
                        if (!p.isHot && p.y < wallY) p.vy += 0.1; // Cold particle above wall, push down
                    }
                    
                    p.el.setAttribute('cx', p.x);
                    p.el.setAttribute('cy', p.y);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawThermo_Master() {
            const variants = [drawThermo_Variant1]; // Prioritizing the new interactive version
            randItem(variants)();
        }

        // --- MASTER DRAWING DISPATCHER ---
        const drawFuncs = {
            spatial: drawSpatial_Master,
            temporal: drawTemporal_Interactive,
            quantum: drawQuantum_Interactive,
            thermo: drawThermo_Master,
            signal: drawSignal_Master,
            default: drawSpatial_Master
        };

        // --- DEFAULT DATA ---
        const defaultLabyrinthTypes = {
            spatial: { name: "Spatial", title: "Architectural Labyrinth (Non-Euclidean)", threat: 4, scenarios: ["A research team is lost inside; their last transmission was 'the map is lying'."], threats: ["Permanent entrapment due to unsolvable topology."], evidence: ["Nav-logs show a ship traveling in a straight line for 10km but ending up at its starting point."], description: "<h4>Primary Paradox:</h4><p>Violation of Euclidean geometry. Manifolds are locally folded, creating impossible connections.</p><h4>Known Variants:</h4><ul><li>Penrose Stairways</li><li>Tesseract Chambers</li></ul><h4>Containment:</h4><p>Uncontained. Standard mapping is useless.</p>" },
            temporal: { name: "Temporal", title: "Temporal Labyrinth (Causal Anomaly)", threat: 7, warning: "High Risk", scenarios: ["An explorer emerges claiming to be from 20 years in the future."], threats: ["Rapid aging to death in seconds."], evidence: ["A weapon that is simultaneously rusted and brand new."], description: "<h4>Primary Paradox:</h4><p>Violation of linear time progression and causality.</p><h4>Known Variants:</h4><ul><li>D√©j√† Vu Loops</li><li>Stasis Fields</li></ul><h4>Containment:</h4><p>Partially contained, but causal contamination is a constant risk.</p>" },
            quantum: { name: "Quantum", title: "Quantum Labyrinth (Macro-State Anomaly)", threat: 5, scenarios: ["A rival faction wants to collapse the Labyrinth into a specific, favorable state."], threats: ["Accidentally observing a lethal state into existence."], evidence: ["Video logs that change every time they are played."], description: "<h4>Primary Paradox:</h4><p>Quantum weirdness manifests at classical scales.</p><h4>Known Variants:</h4><ul><li>Cheshire Walls</li><li>Entangled Rooms</li></ul><h4>Containment:</h4><p>Uncontained. The 'Observer Effect' makes study difficult and dangerous.</p>" },
            thermo: { name: "Thermo", title: "Thermodynamic Labyrinth (Entropic Anomaly)", threat: 6, scenarios: ["The Labyrinth is siphoning heat from the surrounding region, causing a localized ice age."], threats: ["Flash freezing or incineration in adjacent corridors."], evidence: ["A perpetually burning fire in a vacuum-sealed chamber."], description: "<h4>Primary Paradox:</h4><p>Localized violation of the Second Law of Thermodynamics.</p><h4>Known Variants:</h4><ul><li>Perpetual Motion Chambers</li><li>Reassembly Forges</li></ul><h4>Containment:</h4><p>Contained by thermal insulation, but leaks can cause catastrophic environmental shifts.</p>" },
            signal: { name: "Signal", title: "Signal Labyrinth (Informational Anomaly)", threat: 8, warning: "Extreme Risk", scenarios: ["The Labyrinth has infected the team's comms officer."], threats: ["Irreversible insanity from exposure to a logical paradox."], evidence: ["A computer core that melted down after trying to compute 'the last digit of pi'."], description: "<h4>Primary Paradox:</h4><p>Information that has no discernible physical source or violates logical principles.</p><h4>Known Variants:</h4><ul><li>Basilisk Stare</li><li>Logic Bombs</li></ul><h4>Containment:</h4><p>Requires total network isolation ('air gapping').</p>" }
        };
        const defaultArtifacts = { 'TAE-001': { id: 'TAE-001', name: 'Causal Loop Crystal', description: '<p>A crystalline structure that appears to locally violate causality, causing events within its field to repeat in a closed loop. Analysis is ongoing. This is default local data.</p>', source: 'Temporal Labyrinth', hazard: 'Causal Contamination' } };
        const missionData = {
            objectives: ["Investigate", "Retrieve", "Rescue", "Contain", "Destroy", "Stabilize"],
            subjects: ["a research team", "a high-value artifact", "a missing operative", "an unstable energy source", "a rival faction's asset"],
            locations: { surface: ["abandoned mining outpost", "crashed colony ship", "ancient Eryxian ritual site"], orbital: ["a derelict research station", "a defensive satellite", "a space elevator terminus"], space: ["a deep space probe", "a rogue asteroid colony", "a ghost ship"] },
            factions: ["The Stellar Concord", "Terran Ascendancy Mandate (TAM)", "Fractured Humanity Conglomerate", "Pyran Ascendancy", "Eryxian Natives"],
            diseases: ["Causal Rot", "Geometric Cancer", "Temporal Arteritis", "Dimensional Dementia"]
        };
        currentLabyrinthTypes = defaultLabyrinthTypes;
        currentArtifacts = defaultArtifacts;

        // --- WIKI PARSER & FETCHER ---
        function parseWikiData(markdown) {
            const dataRegion = markdown.split('<!-- ERYXIAN-LABYRINTHS-DATA-START -->')[1]?.split('<!-- ERYXIAN-LABYRINTHS-DATA-END -->')[0];
            if (!dataRegion) throw new Error("Could not find data block comments in wiki content.");
            const [classificationsBlock, artifactsBlock] = dataRegion.split('## Labyrinth Artifact Catalog');
            
            const parsedLabyrinths = {};
            classificationsBlock.split('### Labyrinth:').slice(1).forEach(block => {
                const lines = block.trim().split('\n');
                const name = lines[0].trim().toLowerCase();
                if (!name) return;
                const labData = { name: lines[0].trim(), scenarios:[], threats:[], evidence:[], variants:[] };
                let currentList = null, isDescription = false;
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('> Description:')) { isDescription = true; labData.description = ''; continue; }
                    if (isDescription) { labData.description += line.replace(/^>\s?/, ''); continue; }
                    const simplePropMatch = line.match(/^\*\s+([^:]+):\s*(.*)/);
                    if (simplePropMatch) {
                        isDescription = false;
                        const key = simplePropMatch[1].trim(), value = simplePropMatch[2].trim();
                        if (['scenarios', 'threats', 'evidence', 'variants'].includes(key)) { currentList = key; labData[key] = labData[key] || []; }
                        else { labData[key] = value; currentList = null; }
                    } else if (currentList && line.match(/^\s+\*\s/)) { labData[currentList].push(line.replace(/^\s+\*\s+/, '').trim()); }
                }
                if (labData.description && labData.warning) labData.description += `<span class='physics-warning'>${labData.warning}</span>`;
                parsedLabyrinths[name] = labData;
            });

            const parsedArtifacts = {};
            if(artifactsBlock) {
                artifactsBlock.split('### Artifact:').slice(1).forEach(block => {
                    const lines = block.trim().split('\n');
                    const id = lines[0].trim();
                    if(!id) return;
                    const artData = { id };
                    let isDescription = false;
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.startsWith('> Description:')) { isDescription = true; artData.description = ''; continue; }
                        if(isDescription) { artData.description += line.replace(/^>\s?/, ''); continue; }
                        const match = line.match(/\*\s*([^:]+):\s*(.*)/);
                        if(match) {
                            isDescription = false;
                            artData[match[1].trim().toLowerCase().replace(' ', '_')] = match[2].trim();
                        }
                    }
                    parsedArtifacts[id] = artData;
                });
            }
            if (Object.keys(parsedLabyrinths).length > 0) liveLabyrinthTypes = parsedLabyrinths; else throw new Error("No Labyrinth types found.");
            if (Object.keys(parsedArtifacts).length > 0) liveArtifacts = parsedArtifacts;
        }

        async function fetchWikiData() {
            setSyncStatus('syncing');
            try {
                const response = await fetch(WIKI_URL);
                if (!response.ok) throw new Error(`Network response: ${response.statusText}`);
                parseWikiData(await response.text());
                currentLabyrinthTypes = liveLabyrinthTypes;
                currentArtifacts = liveArtifacts;
                setSyncStatus('synced');
            } catch (error) {
                console.error('Wiki Sync Error:', error);
                currentLabyrinthTypes = defaultLabyrinthTypes;
                currentArtifacts = defaultArtifacts;
                setSyncStatus('failed');
            } finally {
                setupViewer();
                if(document.getElementById('content-database').offsetParent !== null) setupArtifactDatabase();
            }
        }
        function setSyncStatus(status) {
            const labels = document.querySelectorAll('.wiki-sync-label');
            const checkboxes = document.querySelectorAll('.wiki-sync-checkbox');
            let text, colorClass, isChecked, isDisabled;
            switch(status) {
                case 'syncing': text = 'Syncing...'; colorClass = 'text-yellow-400'; isChecked = true; isDisabled = true; break;
                case 'synced': text = `Synced (${Object.keys(liveLabyrinthTypes).length} types, ${Object.keys(liveArtifacts).length} artifacts)`; colorClass = 'text-green-400'; isChecked = true; isDisabled = false; break;
                case 'failed': text = 'Sync Failed (Using Default)'; colorClass = 'text-red-400'; isChecked = false; isDisabled = false; break;
                default: text = 'Sync with Live Wiki Data'; colorClass = 'text-gray-400'; isChecked = false; isDisabled = false;
            }
            labels.forEach(l => { l.textContent = text; l.className = `wiki-sync-label text-sm ${colorClass}`; });
            checkboxes.forEach(c => { c.checked = isChecked; c.disabled = isDisabled; });
        }
        
        // --- VIEWER & GENERATOR LOGIC ---
        function setupViewer() {
            DOM.schematicButtonsContainer.innerHTML = '';
            const typeKeys = Object.keys(currentLabyrinthTypes);
            if (typeKeys.length === 0) return;
            typeKeys.forEach(key => {
                const btn = document.createElement('button');
                btn.id = `btn-${key}`; btn.className = 'schematic-btn text-xs sm:text-sm font-medium py-2 px-3 rounded-md'; btn.textContent = currentLabyrinthTypes[key].name;
                btn.addEventListener('click', () => selectLabyrinthType(key));
                DOM.schematicButtonsContainer.appendChild(btn);
            });
            selectLabyrinthType(typeKeys[0]);
        }
        function selectLabyrinthType(typeKey) {
            const type = currentLabyrinthTypes[typeKey];
            if (!type) { console.error(`Type ${typeKey} not found.`); return; }
            document.querySelectorAll('.schematic-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${typeKey}`)?.classList.add('active');
            const threatLevels = {1:'low',2:'low',3:'low',4:'medium',5:'medium',6:'medium',7:'high',8:'high',9:'extreme',10:'extreme'};
            const threatClass = threatLevels[type.threat] || 'low';
            let threatHTML = type.threat ? `<div class="threat-indicator threat-${threatClass}"><p class="text-sm font-semibold">Threat Level: ${type.threat}/10</p></div>` : '';
            DOM.infoPanel.innerHTML = `<h3>${type.title}</h3>${type.description || '<p>No description available.</p>'}${threatHTML}`;
            (drawFuncs[typeKey] || drawFuncs.default)();
        }
        function generateGMContent(contentType) {
            const typeKey = randItem(Object.keys(currentLabyrinthTypes));
            const typeData = currentLabyrinthTypes[typeKey];
            let contentList = typeData[contentType];
            if (!contentList || contentList.length === 0) { DOM.generatorOutput.innerHTML = `<p class="text-gray-500">No '${contentType}' data for ${typeData.name} Labyrinth. Update the wiki!</p>`; return; }
            const randomItem = randItem(contentList);
            const titles = { scenarios: 'üé≤ Scenario Hook', threats: '‚ö†Ô∏è Threat Assessment', evidence: 'üîç Field Evidence' };
            DOM.generatorOutput.innerHTML = `<div class="border-l-4 border-purple-500 pl-4"><h4 class="font-semibold text-purple-300 mb-2">${titles[contentType]}</h4><p class="text-gray-300 leading-relaxed">${randomItem}</p></div>`;
        }
        function generateMissionBrief() {
            const labTypeKey = randItem(Object.keys(currentLabyrinthTypes));
            const labyrinth = currentLabyrinthTypes[labTypeKey];
            const artifactList = Object.values(currentArtifacts);
            const artifact = randItem(artifactList);
            if (!artifact) { DOM.generatorOutput.innerHTML = '<p class="text-red-400">Error: No artifacts available to generate a mission.</p>'; return; }
            DOM.generatorOutput.innerHTML = `<h4 class="text-lg font-bold text-purple-300 mb-2 border-b border-purple-800 pb-1">MISSION BRIEFING</h4> <p><strong>Objective:</strong> ${randItem(missionData.objectives)} <strong class="text-yellow-300">${artifact.name} (${artifact.id})</strong>.</p> <p><strong>Location:</strong> A <strong class="text-yellow-300">${randItem(missionData.locations[DOM.locationSelect.value])}</strong>.</p> <p><strong>Anomaly Type:</strong> <strong class="text-yellow-300">${labyrinth.title}</strong>.</p> <p><strong>Primary Threat:</strong> <strong class="text-red-400">${randItem(labyrinth.threats) || "Unknown"}</strong></p> <p><strong>Complication:</strong> <strong class="text-yellow-300">${randItem(missionData.factions)}</strong> is also on-site.</p> <p><strong>Further Analysis:</strong> Anomaly shows signs of <strong class="text-red-400">${randItem(missionData.diseases)}</strong>.</p>`;
        }

        // --- ARTIFACT DATABASE LOGIC ---
        function setupArtifactDatabase() {
            renderArtifactList();
            DOM.artifactSearch.addEventListener('input', renderArtifactList);
        }
        function renderArtifactList() {
            const searchTerm = DOM.artifactSearch.value.toLowerCase();
            const artifactList = Object.values(currentArtifacts).filter(art => art.name.toLowerCase().includes(searchTerm) || art.id.toLowerCase().includes(searchTerm));
            DOM.artifactList.innerHTML = '';
            artifactList.forEach(art => {
                const btn = document.createElement('button');
                btn.id = `artbtn-${art.id}`;
                btn.className = 'artifact-btn text-left w-full p-2 rounded-md text-sm';
                btn.innerHTML = `<span class="font-semibold">${art.id}</span>: ${art.name}`;
                btn.addEventListener('click', () => selectArtifact(art.id));
                DOM.artifactList.appendChild(btn);
            });
            if (artifactList.length > 0) {
                 selectArtifact(artifactList[0].id);
            } else {
                 DOM.artifactDetailsContainer.classList.add('hidden');
            }
        }
        function selectArtifact(id) {
            const art = currentArtifacts[id];
            if(!art) return;
            document.querySelectorAll('.artifact-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`artbtn-${id}`)?.classList.add('active');
            
            let detailsHTML = `<h3>${art.name} <span class="text-sm font-normal text-gray-400">(${art.id})</span></h3>`;
            if (art.source) detailsHTML += `<h4>Source</h4><p>${art.source}</p>`;
            if (art.hazard) detailsHTML += `<h4>Hazard Type</h4><p>${art.hazard}</p>`;
            if (art.description) detailsHTML += `<h4>Description</h4><p>${art.description}</p>`;
            if (art.image_url) detailsHTML += `<img src="${art.image_url}" alt="Schematic for ${art.name}">`;
            
            DOM.artifactDetails.innerHTML = detailsHTML;
            DOM.artifactDetailsContainer.classList.remove('hidden');
        }

        // --- SIMULATOR LOGIC ---
        let paradoxState = {};
        function startParadoxSim() {
            paradoxState = { step: 0 };
            DOM.paradoxLog.innerHTML = '';
            updateParadoxLog('log-system', 'SIMULATION START: Threshold Gate Anomaly...');
            updateParadoxLog('log-time', '[10:55:00] Preparing Maintenance Drone D-7 for launch at [11:00:00].');
            setTimeout(() => {
                updateParadoxLog('log-alert', '[10:59:01] ALERT: Maintenance Drone D-7 emerges from Gate.');
                updateParadoxLog('log-info', '[10:59:02] Identical to drone D-7. Causal violation detected. Orders?');
                renderParadoxChoices();
            }, 500);
        }
        function updateParadoxLog(type, text) { DOM.paradoxLog.innerHTML += `<p><span class="${type}">${text}</span></p>`; DOM.paradoxLog.scrollTop = DOM.paradoxLog.scrollHeight; }
        function renderParadoxChoices() {
            DOM.paradoxChoices.innerHTML = '';
            if (paradoxState.step === 0) {
                DOM.paradoxChoices.innerHTML = `<button data-choice="send" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Proceed</button> <button data-choice="abort" class="btn-secondary text-white px-4 py-2 rounded-lg text-sm">Abort</button> <button data-choice="mark" class="btn-secondary text-white px-4 py-2 rounded-lg text-sm">Mark & Send</button>`;
            } else {
                DOM.paradoxChoices.innerHTML = `<button data-choice="restart" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Run Again</button>`;
            }
        }
        
        let probeState = {};
        function startProbeSim() { probeState = { currentNodeId: 'node-0' }; DOM.probeLog.innerHTML = ''; updateProbeLog('log-system', `Launching deep exploration probe...`); renderProbeNode(); }
        function generateProbeNode(nodeId) {
            const typeKey = randItem(Object.keys(currentLabyrinthTypes)); const typeData = currentLabyrinthTypes[typeKey];
            if (nodeId === 'node-0') return { description: 'Initial entry point. The air hums with anomalous energy.', choices: { 'Proceed cautiously': 'node-1' } };
            if(Math.random() < 0.3) return { description: `${randItem(typeData.threats) || "Catastrophic failure"}. Probe sensors overload. Signal lost.`, choices: {} };
            return { description: `Probe detects: ${randItem(typeData.evidence) || "strange readings"}.`, choices: { 'Go Left': `node-${Math.random()}`, 'Go Right': `node-${Math.random()}` } };
        }
        function renderProbeNode() {
            const node = generateProbeNode(probeState.currentNodeId); updateProbeLog('log-probe', `[NODE ${probeState.currentNodeId.substring(0,6)}] ${node.description}`); DOM.probeChoices.innerHTML = '';
            if (Object.keys(node.choices).length === 0) DOM.probeChoices.innerHTML = `<button data-choice="restart" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Launch New Probe</button>`;
            else Object.entries(node.choices).forEach(([text, targetNodeId]) => { const btn = document.createElement('button'); btn.className = 'btn-secondary text-white px-4 py-2 rounded-lg text-sm'; btn.textContent = text; btn.dataset.target = targetNodeId; DOM.probeChoices.appendChild(btn); });
        }
        function updateProbeLog(type, text) { DOM.probeLog.innerHTML += `<p><span class="${type}">${text}</span></p>`; DOM.probeLog.scrollTop = DOM.probeLog.scrollHeight; }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            DOM = {
                svg: document.getElementById('schematic-svg'), infoPanel: document.getElementById('info-panel'), schematicButtonsContainer: document.getElementById('schematic-buttons'), generatorOutput: document.getElementById('generator-output'),
                locationSelect: document.getElementById('location-select'), paradoxLog: document.getElementById('paradox-log'), paradoxChoices: document.getElementById('paradox-choices'), probeLog: document.getElementById('probe-log'), probeChoices: document.getElementById('probe-choices'),
                allTabs: document.querySelectorAll('.main-tab'), allContent: document.querySelectorAll('[id^="content-"]'), allSyncCheckboxes: document.querySelectorAll('.wiki-sync-checkbox'),
                artifactList: document.getElementById('artifact-list'), artifactSearch: document.getElementById('artifact-search'), artifactDetails: document.getElementById('artifact-details'), artifactDetailsContainer: document.getElementById('artifact-details-container')
            };
            
            DOM.allTabs.forEach(tab => tab.addEventListener('click', e => {
                const targetTab = e.target.dataset.tab;
                DOM.allTabs.forEach(t => t.classList.remove('active')); e.target.classList.add('active');
                DOM.allContent.forEach(c => { c.classList.add('hidden'); c.classList.remove('grid'); });
                const targetContent = document.getElementById(`content-${targetTab}`);
                targetContent.classList.remove('hidden');
                
                if(['viewer', 'database', 'simulator'].includes(targetTab)) targetContent.classList.add('grid');
                if(targetTab === 'viewer' && Object.keys(currentLabyrinthTypes).length > 0) selectLabyrinthType(document.querySelector('.schematic-btn.active')?.id.replace('btn-', '') || Object.keys(currentLabyrinthTypes)[0]);
                if(targetTab === 'simulator') { startParadoxSim(); startProbeSim(); }
                if(targetTab === 'database') setupArtifactDatabase();
            }));

            DOM.allSyncCheckboxes.forEach(checkbox => checkbox.addEventListener('change', e => {
                if (e.target.checked) fetchWikiData();
                else { 
                    currentLabyrinthTypes = defaultLabyrinthTypes; 
                    currentArtifacts = defaultArtifacts;
                    setSyncStatus('default'); 
                    setupViewer();
                    if(document.getElementById('content-database').offsetParent !== null) setupArtifactDatabase();
                }
            }));

            document.getElementById('gm-brief').addEventListener('click', generateMissionBrief);
            document.getElementById('gm-scenario').addEventListener('click', () => generateGMContent('scenarios'));
            document.getElementById('gm-threat').addEventListener('click', () => generateGMContent('threats'));
            document.getElementById('gm-evidence').addEventListener('click', () => generateGMContent('evidence'));

            DOM.paradoxChoices.addEventListener('click', e => {
                const choice = e.target.dataset.choice; if (!choice) return;
                if (choice === 'restart') { startParadoxSim(); return; }
                paradoxState.step = 1; updateParadoxLog('log-action', `[DECISION] ${e.target.textContent}`);
                switch(choice) {
                    case 'send': updateParadoxLog('log-info', '[11:00:00] Drone enters Gate. Loop closed. Event self-consistent.'); break;
                    case 'abort': updateParadoxLog('log-alert', '[11:00:00] Drone wrenched from grasp, flies into Gate. Labyrinth enforces consistency.'); break;
                    case 'mark': updateParadoxLog('log-info', '[10:59:30] Mark appears on emerged drone. Labyrinth enforces consistency retroactively.'); break;
                }
                updateParadoxLog('log-system', 'SIMULATION COMPLETE.'); renderParadoxChoices();
            });

            DOM.probeChoices.addEventListener('click', e => {
                const choice = e.target.dataset.choice; const targetNode = e.target.dataset.target;
                if (choice === 'restart') { startProbeSim(); return; } 
                if (!targetNode) return;
                probeState.currentNodeId = targetNode; renderProbeNode();
            });

            setupViewer();
        });
    </script>
</body>
</html>