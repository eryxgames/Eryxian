<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eryxian Labyrinth Research Interface v6.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); }
        .glass-effect { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(12px); border: 1px solid rgba(75, 85, 99, 0.3); }
        .main-tab { transition: all 0.3s ease; border-bottom: 2px solid transparent; }
        .main-tab.active { border-bottom-color: #818cf8; color: #e0e7ff; text-shadow: 0 0 8px rgba(129, 140, 248, 0.5); }
        .info-box h3, .artifact-details h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: #c7d2fe; border-bottom: 1px solid #4a5568; padding-bottom: 0.5rem; text-shadow: 0 0 10px rgba(199, 210, 254, 0.3); }
        .info-box h4, .artifact-details h4 { font-size: 0.875rem; font-weight: 700; color: #a5b4fc; margin-top: 1rem; margin-bottom: 0.25rem; }
        .info-box p, .info-box li, .artifact-details p { font-size: 0.875rem; line-height: 1.6; }
        .info-box ul { list-style-type: '‚Ä∫ '; padding-left: 1rem; margin-bottom: 1rem; }
        .schematic-btn, .artifact-btn { transition: all 0.3s ease; background-color: rgba(75, 85, 99, 0.3); }
        .schematic-btn:hover, .artifact-btn:hover { background-color: rgba(99, 102, 241, 0.3); }
        .schematic-btn.active, .artifact-btn.active { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; box-shadow: 0 8px 15px -8px rgba(79, 70, 229, 0.5); transform: translateY(-1px); }
        .gm-output, .simulation-window { background: rgba(17, 24, 39, 0.8); backdrop-filter: blur(8px); border: 1px solid rgba(55, 65, 81, 0.5); transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(79, 70, 229, 0.6); }
        .btn-secondary { background-color: rgba(75, 85, 99, 0.4); border: 1px solid rgba(129, 140, 248, 0.3); transition: all 0.3s ease; }
        .btn-secondary:hover { background-color: rgba(99, 102, 241, 0.3); }
        .threat-indicator { border-left: 4px solid; padding: 0.5rem 1rem; margin-top: 1rem; border-radius: 0 0.375rem 0.375rem 0; }
        .threat-low { border-color: #10b981; background: rgba(16, 185, 129, 0.1); }
        .threat-medium { border-color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
        .threat-high { border-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        .threat-extreme { border-color: #dc2626; background: rgba(220, 38, 38, 0.15); box-shadow: 0 0 20px rgba(220, 38, 38, 0.2); }
        .physics-warning { background: linear-gradient(45deg, #dc2626, #f59e0b); color: white; padding: 2px 8px; border-radius: 9999px; font-size: 0.7rem; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); animation: glow 2s ease-in-out infinite alternate; display: inline-block; }
        @keyframes glow { from { box-shadow: 0 0 5px rgba(220, 38, 38, 0.5); } to { box-shadow: 0 0 15px rgba(220, 38, 38, 0.8); } }
        .custom-select, .custom-checkbox, .search-input { background-color: rgba(31, 41, 55, 0.8); border: 1px solid #4a5568; }
        .sim-log { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
        .sim-log p { margin-bottom: 0.5rem; }
        .log-time { color: #6ee7b7; } .log-alert { color: #f87171; font-weight: bold; } .log-action { color: #facc15; } .log-info { color: #93c5fd; } .log-system { color: #a78bfa; font-style: italic; } .log-probe { color: #c4b5fd; }
        .logo { height: 4rem; width: auto; filter: drop-shadow(0 0 10px rgba(129, 140, 248, 0.6)); transition: all 0.3s ease; }
        .logo:hover { filter: drop-shadow(0 0 15px rgba(165, 180, 252, 0.8)); transform: scale(1.05); }
        .main-header-grid { position: relative; display: flex; justify-content: space-between; align-items: center; min-height: 4rem; }
        .header-column { flex: 1; }
        .artifact-list { max-height: 450px; }
        .artifact-details img { max-width: 100%; height: auto; margin-top: 1rem; border-radius: 0.5rem; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); }
        #schematic-svg { cursor: pointer; }
        @media (min-width: 768px) { .logo-glow { position: absolute; left: 50%; transform: translateX(-50%); width: auto; } }
        @media (max-width: 767px) { .main-header-grid { flex-direction: column; gap: 1rem; } .header-column { flex-basis: auto; text-align: center !important; } .header-column a { justify-content: center; } }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-7xl glass-effect rounded-2xl shadow-2xl p-4 sm:p-6 lg:p-8">
        <header class="mb-6">
            <div class="main-header-grid mb-4 flex-wrap">
                <div class="text-left header-column">
                    <a href="https://eryxian.com" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm transition-colors duration-200 flex items-center gap-1">üåê Eryxian.com</a>
                    <a href="https://github.com/eryxgames/Eryxian/wiki" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm transition-colors duration-200 flex items-center gap-1 mt-1">üìö Universe Wiki</a>
                </div>
                <div class="logo-glow order-first md:order-none">
                    <img src="https://raw.githubusercontent.com/eryxgames/Eryxian/main/eryxian-dash-logo-sm.png" alt="Eryxian Research Interface" class="logo">
                </div>
                <div class="text-right header-column">
                    <a href="https://github.com/eryxgames/Eryxian/wiki/Eryxian-Labyrinths" target="_blank" class="text-purple-400 hover:text-purple-300 text-sm transition-colors duration-200 flex items-center gap-1 justify-end">üî¨ Labyrinths Research</a>
                </div>
            </div>
            <div class="text-center">
                <h1 class="text-3xl sm:text-4xl font-bold text-white mb-2 bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 bg-clip-text text-transparent">Eryxian Labyrinth Research Interface</h1>
                <p class="text-sm sm:text-base text-gray-400 mt-2">Field Anomaly Classification & GM Toolkit v6.0</p>
            </div>
        </header>

        <div class="border-b border-gray-700 mb-6">
            <nav class="flex justify-center -mb-px space-x-4 sm:space-x-8">
                <button data-tab="viewer" class="main-tab active text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Classification Viewer</button>
                <button data-tab="database" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Artifact Database</button>
                <button data-tab="generator" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">GM Toolkit</button>
                <button data-tab="simulator" class="main-tab text-gray-400 hover:text-white whitespace-nowrap py-4 px-1 font-medium text-sm">Interactive Simulation</button>
            </nav>
        </div>

        <div id="content-viewer" class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 glass-effect rounded-xl flex items-center justify-center p-4 min-h-[400px] lg:min-h-[500px] overflow-hidden">
                <svg id="schematic-svg" class="w-full h-full" viewBox="0 0 500 400"></svg>
            </div>
            <div class="glass-effect rounded-xl p-6">
                 <div class="flex items-center gap-2 mb-4">
                    <input type="checkbox" id="wiki-sync-viewer" class="wiki-sync-checkbox custom-checkbox w-4 h-4 rounded">
                    <label for="wiki-sync-viewer" class="wiki-sync-label text-sm text-gray-400">Sync with Live Wiki Data</label>
                </div>
                <div id="schematic-buttons" class="grid grid-cols-2 gap-2 mb-4"></div>
                <div id="info-panel" class="info-box max-h-[420px] overflow-y-auto pr-2"></div>
            </div>
        </div>

        <div id="content-database" class="hidden grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1 glass-effect rounded-xl p-4">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Artifact Catalog</h3>
                <input type="text" id="artifact-search" class="search-input w-full p-2 rounded-md mb-2 text-sm" placeholder="Search artifacts...">
                <div id="artifact-list" class="artifact-list overflow-y-auto pr-2 space-y-2"></div>
            </div>
            <div id="artifact-details-container" class="md:col-span-2 glass-effect rounded-xl p-6 hidden">
                <div id="artifact-details" class="overflow-y-auto max-h-[500px] pr-2"></div>
            </div>
        </div>

        <div id="content-generator" class="hidden">
             <div class="gm-output rounded-lg p-6">
                <div class="flex justify-between items-start mb-4 flex-wrap gap-4">
                    <h3 class="text-lg font-semibold text-purple-300">Anomaly Generator & GM Tools</h3>
                    <div class="flex gap-4 items-center flex-wrap">
                        <div class="flex items-center gap-2">
                             <label for="location-select" class="text-sm font-medium text-gray-400">Location:</label>
                             <select id="location-select" class="custom-select text-sm rounded-md py-1 px-2">
                                 <option value="surface">Surface</option>
                                 <option value="orbital">Low Orbit</option>
                                 <option value="space">Deep Space</option>
                             </select>
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="wiki-sync-generator" class="wiki-sync-checkbox custom-checkbox w-4 h-4 rounded">
                            <label for="wiki-sync-generator" class="wiki-sync-label text-sm text-gray-400">Sync with Live Wiki Data</label>
                        </div>
                    </div>
                </div>
                <div class="flex justify-center gap-2 flex-wrap mb-6">
                    <button id="gm-brief" class="btn-primary text-white px-4 py-2 rounded-lg text-sm font-semibold">Generate Mission Brief</button>
                    <button id="gm-scenario" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Hook</button>
                    <button id="gm-threat" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Threat</button>
                    <button id="gm-evidence" class="btn-secondary text-white px-3 py-1 rounded-lg text-xs">Evidence</button>
                </div>
                <div id="generator-output" class="text-sm text-gray-300 min-h-[250px] transition-all duration-300 bg-black/20 p-4 rounded-md">
                    Select a generator tool to begin...
                </div>
            </div>
        </div>
        
        <div id="content-simulator" class="hidden grid-cols-1 md:grid-cols-2 gap-6">
            <div class="simulation-window rounded-lg p-6">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Simulation: The Threshold Gate Paradox</h3>
                <p class="text-sm text-gray-400 mb-4">Investigating Incident Report: New Eden Settlement.</p>
                <div id="paradox-log" class="sim-log text-sm min-h-[200px] bg-black/30 p-4 rounded-md mb-4 overflow-y-auto max-h-[300px]"></div>
                <div id="paradox-choices" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
            <div class="simulation-window rounded-lg p-6">
                <h3 class="text-lg font-semibold text-purple-300 mb-2">Simulation: Labyrinth Probe Explorer</h3>
                <p class="text-sm text-gray-400 mb-4">Minimalist probe data feed from a generated anomaly.</p>
                <div id="probe-log" class="sim-log text-sm min-h-[200px] bg-black/30 p-4 rounded-md mb-4 overflow-y-auto max-h-[300px]"></div>
                <div id="probe-choices" class="flex gap-4 flex-wrap justify-center"></div>
            </div>
        </div>
    </div>

    <!-- Footer Section -->
    <footer class="text-center text-xs text-gray-500 mt-8 pb-4 px-4">
        <p>Eryxian Universe Game World created by Daniel Sandner, Copyright ¬© 2025 (see licenses on the content repositories of the <a href="https://github.com/eryxgames" target="_blank" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Eryxian Open Project</a>).</p>
    </footer>

    <script>
        // --- DATA & CONFIG ---
        const WIKI_URL = 'https://raw.githubusercontent.com/wiki/eryxgames/Eryxian/Eryxian-Labyrinths-Research-Data.md';
        let liveLabyrinthTypes = {};
        let liveArtifacts = {};
        let currentLabyrinthTypes = {};
        let currentArtifacts = {};
        const randItem = (arr) => arr && arr.length > 0 ? arr[Math.floor(Math.random() * arr.length)] : null;
        let DOM = {};

// --- ENHANCED & VARIANT DRAWING FUNCTIONS ---

let activeSVGListeners = []; // Holds active listeners for easy removal

// Helper to add and track listeners
function addTrackedListener(target, event, handler) {
    target.addEventListener(event, handler);
    activeSVGListeners.push({ target, event, handler });
}

function clearSVG() {
    if (window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
    
    activeSVGListeners.forEach(({ target, event, handler }) => {
        target.removeEventListener(event, handler);
    });
    activeSVGListeners = [];

    if (DOM.svg) {
        DOM.svg.innerHTML = '';
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const glowFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        glowFilter.id = 'glow';
        glowFilter.innerHTML = `<feGaussianBlur stdDeviation="3.5" result="coloredBlur"></feGaussianBlur><feMerge><feMergeNode in="coloredBlur"></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge>`;
        defs.appendChild(glowFilter);
        DOM.svg.appendChild(defs);
    }
}

// --- Spatial Labyrinth Functions ---

function drawSpatial_Interactive() { // Hyperspace Slicer with Ghost Geometry & Reversible Rotation
    clearSVG();
    const center_x = 250, center_y = 200;
    let sliceW = 0;
    let rotation = { xy: 0.01, zw: 0.02, xw: 0.03 };
    let rotationDirection = 1; // NEW: State variable for rotation direction (1 = forward, -1 = backward)

    const vertices = Array.from({length: 16}, (_, i) => ({ x:(i&1?-1:1), y:(i&2?-1:1), z:(i&4?-1:1), w:(i&8?-1:1) }));
    const edges = [[0,1],[0,2],[0,4],[0,8],[1,3],[1,5],[1,9],[2,3],[2,6],[2,10],[3,7],[3,11],[4,5],[4,6],[4,12],[5,7],[5,13],[6,7],[6,14],[7,15],[8,9],[8,10],[8,12],[9,11],[9,13],[10,11],[10,14],[11,15],[12,13],[12,14],[13,15],[14,15]];

    const ghostLines = edges.map(() => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('stroke', 'rgba(75, 85, 99, 0.9)');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-dasharray', '2 4');
        DOM.svg.appendChild(line);
        return line;
    });

    const sliceShape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    sliceShape.setAttribute('fill', 'rgba(129, 140, 248, 0.25)');
    sliceShape.setAttribute('stroke', 'rgba(224, 231, 255, 1)');
    sliceShape.setAttribute('stroke-width', '2');
    sliceShape.style.filter = 'url(#glow)';
    DOM.svg.appendChild(sliceShape);

    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        sliceW = ((e.clientY - rect.top) / rect.height) * 2.2 - 1.1;
    });

    // NEW: Click listener to reverse direction
    addTrackedListener(DOM.svg, 'click', () => {
        rotationDirection *= -1; // Invert the direction
    });

    function animate() {
        // MODIFIED: Apply direction to rotation increments
        rotation.xy += 0.002 * rotationDirection;
        rotation.zw += 0.003 * rotationDirection;
        rotation.xw += 0.004 * rotationDirection;

        const r = (a) => ({ c: Math.cos(a), s: Math.sin(a) });
        let r_xy = r(rotation.xy), r_zw = r(rotation.zw), r_xw = r(rotation.xw);
        
        const rotatedVertices = vertices.map(v => {
            let x=v.x, y=v.y, z=v.z, w=v.w;
            [x,y] = [x*r_xy.c - y*r_xy.s, x*r_xy.s + y*r_xy.c];
            [z,w] = [z*r_zw.c - w*r_zw.s, z*r_zw.s + w*r_zw.c];
            [x,w] = [x*r_xw.c - w*r_xw.s, x*r_xw.s + w*r_xw.c];
            return {x,y,z,w};
        });
        
        const intersectionPoints = [];
        let ghostLineIndex = 0;
        const scale = 250; // Use a variable for scale for easy adjustment

        edges.forEach(edge => {
            const v1 = rotatedVertices[edge[0]];
            const v2 = rotatedVertices[edge[1]];
            
            const p1_2d = { p: 1.5/(4 - v1.z), x: v1.x, y: v1.y };
            const p2_2d = { p: 1.5/(4 - v2.z), x: v2.x, y: v2.y };

            if ((v1.w < sliceW && v2.w > sliceW) || (v1.w > sliceW && v2.w < sliceW)) {
                const t = (sliceW - v1.w) / (v2.w - v1.w);
                const ix = v1.x + t * (v2.x - v1.x), iy = v1.y + t * (v2.y - v1.y), iz = v1.z + t * (v2.z - v1.z);
                const p = 1.5 / (4 - iz);
                intersectionPoints.push({ x: ix*p*scale + center_x, y: iy*p*scale + center_y });
            } else if (v1.w > sliceW && v2.w > sliceW) {
                if(ghostLineIndex < ghostLines.length) {
                    const line = ghostLines[ghostLineIndex++];
                    line.setAttribute('x1', p1_2d.x * p1_2d.p * scale + center_x);
                    line.setAttribute('y1', p1_2d.y * p1_2d.p * scale + center_y);
                    line.setAttribute('x2', p2_2d.x * p2_2d.p * scale + center_x);
                    line.setAttribute('y2', p2_2d.y * p2_2d.p * scale + center_y);
                    line.style.display = 'block';
                }
            }
        });

        for (let i = ghostLineIndex; i < ghostLines.length; i++) ghostLines[i].style.display = 'none';

        if (intersectionPoints.length > 2) {
            const centroid = intersectionPoints.reduce((a, p) => ({x:a.x+p.x, y:a.y+p.y}), {x:0, y:0});
            centroid.x /= intersectionPoints.length; centroid.y /= intersectionPoints.length;
            intersectionPoints.sort((a,b) => Math.atan2(a.y-centroid.y, a.x-centroid.x) - Math.atan2(b.y-centroid.y, b.x-centroid.x));
            sliceShape.setAttribute('points', intersectionPoints.map(p => `${p.x},${p.y}`).join(' '));
        } else {
            sliceShape.setAttribute('points', '');
        }

        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Variant1() { // Unfolding Tesseract Net with Enhanced Visuals
    clearSVG();
    const center_x = 250, center_y = 200;
    let unfoldFactor = 0;
    let rotation = { xy: 0, xz: 0, yz: 0 };
    let rotationMode = 0;
    let t = 0;

    const rotationProfiles = [
        { xy: 0.005, xz: 0.003, yz: 0 },         // Smooth Tumble
        { xy: 0, xz: 0, yz: 0.01 },              // Flat Spin
        { xy: 0.008, xz: 0, yz: 0 },              // Top-down Spin
        { xy: 0, xz: 0.007, yz: 0.007 }          // Diagonal Spin
    ];
    
    addTrackedListener(DOM.svg, 'click', () => {
        rotationMode = (rotationMode + 1) % rotationProfiles.length;
    });

    const cubeVertices = Array.from({length: 8}, (_, i) => ({ x: (i&1?0.5:-0.5), y: (i&2?0.5:-0.5), z: (i&4?0.5:-0.5) }));
    const cubeEdges = [[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]];
    const netOffsets = [ {x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:-1,z:0}, {x:0,y:0,z:1}, {x:0,y:0,z:-1}, {x:2,y:0,z:0} ];
    
    const cubes = netOffsets.map(() => cubeEdges.map(() => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.style.filter = 'url(#glow)'; // Apply glow to all
        DOM.svg.appendChild(line);
        return line;
    }));
    
    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        unfoldFactor = (e.clientX - rect.left) / rect.width;
        rotation.yz = ((e.clientY - rect.top) / rect.height - 0.5) * Math.PI * (1 - unfoldFactor); // Dampen manual rotation when unfolded
    });

    function animate() {
        t++;
        const profile = rotationProfiles[rotationMode];
        rotation.xy += profile.xy; rotation.xz += profile.xz;
        // The yz rotation is a combination of profile and mouse for more dynamic control
        let currentYz = rotation.yz + (profile.yz * t);

        netOffsets.forEach((offset, cubeIndex) => {
            const interpolatedOffset = {
                x: offset.x * unfoldFactor,
                y: offset.y * unfoldFactor,
                z: offset.z * unfoldFactor,
            };
            const dist = Math.sqrt(interpolatedOffset.x**2 + interpolatedOffset.y**2 + interpolatedOffset.z**2);
            const styleFactor = 0.5 + Math.min(dist * 0.5, 0.5); // Factor from 0.5 to 1.0 based on distance

            const projected = cubeVertices.map(v => {
                let x = v.x + interpolatedOffset.x, y = v.y + interpolatedOffset.y, z = v.z + interpolatedOffset.z;
                const r = (a) => ({ c: Math.cos(a), s: Math.sin(a) });
                let r_xy = r(rotation.xy), r_xz = r(rotation.xz), r_yz = r(currentYz);
                [x,y] = [x*r_xy.c - y*r_xy.s, x*r_xy.s + y*r_xy.c];
                [x,z] = [x*r_xz.c - z*r_xz.s, x*r_xz.s + z*r_xz.c];
                [y,z] = [y*r_yz.c - z*r_yz.s, y*r_yz.s + z*r_yz.c];

                const perspective = 1.5 / (4 - z);
                // Scaling factor
                return { x: x * perspective * 220 + center_x, y: y * perspective * 220 + center_y };
            });

            cubeEdges.forEach((edge, edgeIndex) => {
                const p1 = projected[edge[0]], p2 = projected[edge[1]];
                const line = cubes[cubeIndex][edgeIndex];
                line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y);
                line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
                line.setAttribute('stroke', `rgba(199, 210, 254, ${0.5 + styleFactor * 0.5})`);
                line.setAttribute('stroke-width', 0.5 + styleFactor);
            });
        });

        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Variant2() { // Nested 5D Penteract
    clearSVG();
    const center_x = 250, center_y = 200;
    let rot = { xw: 0, yw: 0, zw: 0.1, xy: 0.2, yz: 0.3 };

    const createTesseract = (size) => {
        const vertices = [];
        for (let i = 0; i < 16; i++) {
            vertices.push({
                x: (i & 1 ? size : -size), y: (i & 2 ? size : -size),
                z: (i & 4 ? size : -size), w: (i & 8 ? size : -size)
            });
        }
        const edges = [
            [0,1],[0,2],[0,4],[0,8],[1,3],[1,5],[1,9],[2,3],[2,6],[2,10],[3,7],[3,11],
            [4,5],[4,6],[4,12],[5,7],[5,13],[6,7],[6,14],[7,15],[8,9],[8,10],[8,12],
            [9,11],[9,13],[10,11],[10,14],[11,15],[12,13],[12,14],[13,15],[14,15]
        ];
        return { vertices, edges };
    };

    const tesseractOuter = createTesseract(1);
    const tesseractInner = createTesseract(0.5);
    
    const allEdges = [
        ...tesseractOuter.edges,
        ...tesseractInner.edges,
        ...Array.from({length: 16}, (_, i) => [i, i]) // Placeholder for connectors
    ];

    const edgeElements = allEdges.map((edge, i) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        if (i < tesseractOuter.edges.length) { // Outer
            line.setAttribute('stroke', 'rgba(199, 210, 254, 0.7)'); line.setAttribute('stroke-width', '1.5');
        } else if (i < tesseractOuter.edges.length + tesseractInner.edges.length) { // Inner
            line.setAttribute('stroke', 'rgba(165, 180, 252, 0.9)'); line.setAttribute('stroke-width', '1');
        } else { // Connectors
            line.setAttribute('stroke', 'rgba(129, 140, 248, 1)'); line.setAttribute('stroke-width', '2'); line.style.filter = 'url(#glow)';
        }
        DOM.svg.appendChild(line);
        return line;
    });
    
    addTrackedListener(DOM.svg, 'mousemove', e => {
        const rect = DOM.svg.getBoundingClientRect();
        rot.yw = ((e.clientX - rect.left) / rect.width - 0.5) * Math.PI;
        rot.xw = ((e.clientY - rect.top) / rect.height - 0.5) * Math.PI;
    });

    let t = 0;
    function animate() {
        t += 0.01;
        const project = (v, scale, rotationOffset) => {
            let x=v.x, y=v.y, z=v.z, w=v.w;
            const r = (r, a, b) => { let c=Math.cos(r), s=Math.sin(r); return { c:c, s:s }; };
            
            let r_xw = r(rot.xw + rotationOffset, x, w), r_yw = r(rot.yw + rotationOffset, y, w), r_zw = r(rot.zw, z, w);
            let r_xy = r(rot.xy, x, y), r_yz = r(rot.yz, y, z);
            
            [x,w] = [x*r_xw.c - w*r_xw.s, x*r_xw.s + w*r_xw.c];
            [y,w] = [y*r_yw.c - w*r_yw.s, y*r_yw.s + w*r_yw.c];
            [z,w] = [z*r_zw.c - w*r_zw.s, z*r_zw.s + w*r_zw.c];
            [x,y] = [x*r_xy.c - y*r_xy.s, x*r_xy.s + y*r_xy.c];
            [y,z] = [y*r_yz.c - z*r_yz.s, y*r_yz.s + z*r_yz.c];

            const perspective = 1.5 / (4 - w);
            return { x: x * perspective * scale + center_x, y: y * perspective * scale + center_y, w: w };
        };
        // Changing the scale of tesseract on screen
        const p_outer = tesseractOuter.vertices.map(v => project(v, 270, 0));
        const p_inner = tesseractInner.vertices.map(v => project(v, 240, Math.sin(t*0.5)*0.5));
        
        edgeElements.forEach((el, i) => {
            if (i < 32) { // Outer tesseract
                const edge = tesseractOuter.edges[i];
                el.setAttribute('x1', p_outer[edge[0]].x); el.setAttribute('y1', p_outer[edge[0]].y);
                el.setAttribute('x2', p_outer[edge[1]].x); el.setAttribute('y2', p_outer[edge[1]].y);
            } else if (i < 64) { // Inner tesseract
                const edge = tesseractInner.edges[i - 32];
                el.setAttribute('x1', p_inner[edge[0]].x); el.setAttribute('y1', p_inner[edge[0]].y);
                el.setAttribute('x2', p_inner[edge[1]].x); el.setAttribute('y2', p_inner[edge[1]].y);
            } else { // Connectors
                const vertexIndex = i - 64;
                el.setAttribute('x1', p_outer[vertexIndex].x); el.setAttribute('y1', p_outer[vertexIndex].y);
                el.setAttribute('x2', p_inner[vertexIndex].x); el.setAttribute('y2', p_inner[vertexIndex].y);
                const avgW = (p_outer[vertexIndex].w + p_inner[vertexIndex].w) / 2;
                el.style.opacity = Math.max(0.1, (avgW + 1) / 2); // Dim lines that are "further away" in 4D
            }
        });
        
        rot.xy += 0.001; rot.yz += 0.002; rot.zw += 0.003;
        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Variant3() { // Interactive Inverse Geometry Portal
    clearSVG();
    const portal = { x: 250, y: 200, r: 100, vx: 0.3, vy: 0.2 };
    let isPortalLocked = false;
    const gridLines = [];

    const portalVisual = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    portalVisual.setAttribute('cx', portal.x); portalVisual.setAttribute('cy', portal.y);
    portalVisual.setAttribute('fill', 'none'); portalVisual.setAttribute('stroke', '#818cf8');
    portalVisual.setAttribute('stroke-width', '2'); portalVisual.style.filter = 'url(#glow)';
    
    for (let i = 0; i <= 10; i++) {
        [{type:'h', pos: i*40, step:10}, {type:'v', pos: i*50, step:8}].forEach(spec => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            line.setAttribute('fill', 'none'); line.setAttribute('stroke', 'rgba(165, 180, 252, 0.3)'); line.setAttribute('stroke-width', '1');
            DOM.svg.appendChild(line);
            gridLines.push({ type: spec.type, pos: spec.pos, el: line, step: spec.step });
        });
    }
    DOM.svg.appendChild(portalVisual); // Add portal on top

    addTrackedListener(DOM.svg, 'mousemove', e => {
        if (isPortalLocked) return;
        const rect = DOM.svg.getBoundingClientRect();
        const viewBox = DOM.svg.viewBox.baseVal;
        portal.x = (e.clientX - rect.left) * (viewBox.width / rect.width);
        portal.y = (e.clientY - rect.top) * (viewBox.height / rect.height);
    });

    addTrackedListener(DOM.svg, 'click', () => { isPortalLocked = !isPortalLocked; });

    let t = 0;
    function animate() {
        t += 0.015;
        if (isPortalLocked) {
            portal.x = 250 + Math.sin(t * 0.7) * 100;
            portal.y = 200 + Math.cos(t * 0.5) * 80;
        }

        const radius = 100 * (1 + Math.sin(t * 2) * 0.15);
        const r2 = radius * radius;
        
        portalVisual.setAttribute('cx', portal.x); portalVisual.setAttribute('cy', portal.y);
        portalVisual.setAttribute('r', radius);

        gridLines.forEach(line => {
            let pointsStr = '';
            for (let i = 0; i <= 50; i++) {
                const p = (line.type === 'h') ? {x: i * line.step, y: line.pos} : {x: line.pos, y: i * line.step};
                const dx = p.x - portal.x, dy = p.y - portal.y;
                const d2 = dx * dx + dy * dy;
                if (d2 < 0.1) continue;
                const factor = r2 / d2;
                pointsStr += `${portal.x + dx * factor},${portal.y + dy * factor} `;
            }
            line.el.setAttribute('points', pointsStr);
        });
        
        window.animationFrameId = requestAnimationFrame(animate);
    }
    animate();
}

function drawSpatial_Master() {
    const variants = [drawSpatial_Interactive, drawSpatial_Variant1, drawSpatial_Variant2, drawSpatial_Variant3];
    randItem(variants)();
}

        // --- Temporal Labyrinth Functions ---

        function drawTemporal_Interactive() {
            clearSVG();
            const clockFace = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            clockFace.setAttribute('cx', '250'); clockFace.setAttribute('cy', '200'); clockFace.setAttribute('r', '150');
            clockFace.setAttribute('fill', 'rgba(165, 180, 252, 0.1)'); clockFace.setAttribute('stroke', '#a5b4fc'); clockFace.setAttribute('stroke-width', '1');
            DOM.svg.appendChild(clockFace);

            const hourHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hourHand.setAttribute('x1', '250'); hourHand.setAttribute('y1', '200'); hourHand.setAttribute('stroke', '#e0e7ff');
            hourHand.setAttribute('stroke-width', '6'); hourHand.setAttribute('stroke-linecap', 'round');
            DOM.svg.appendChild(hourHand);

            const minuteHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            minuteHand.setAttribute('x1', '250'); minuteHand.setAttribute('y1', '200'); minuteHand.setAttribute('stroke', '#c7d2fe');
            minuteHand.setAttribute('stroke-width', '4'); minuteHand.setAttribute('stroke-linecap', 'round');
            DOM.svg.appendChild(minuteHand);
            
            let time = 0;
            let timeWarpFactor = 0.01;

            addTrackedListener(DOM.svg, 'mousemove', (e) => {
                const rect = DOM.svg.getBoundingClientRect();
                timeWarpFactor = ((e.clientX - rect.left) / rect.width - 0.5) * 0.1;
            });

            addTrackedListener(DOM.svg, 'click', () => {
                time += Math.random() * 2 - 1; // Time jump
                clockFace.setAttribute('fill', 'rgba(239, 68, 68, 0.3)');
                setTimeout(() => clockFace.setAttribute('fill', 'rgba(165, 180, 252, 0.1)'), 100);
            });

            function animate() {
                time += timeWarpFactor;
                const hourAngle = (time * 0.5);
                const minuteAngle = (time * 2);
                hourHand.setAttribute('x2', 250 + 80 * Math.cos(hourAngle));
                hourHand.setAttribute('y2', 200 + 80 * Math.sin(hourAngle));
                minuteHand.setAttribute('x2', 250 + 120 * Math.cos(minuteAngle));
                minuteHand.setAttribute('y2', 200 + 120 * Math.sin(minuteAngle));
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        // --- Quantum Labyrinth Functions ---

        function drawQuantum_Interactive() {
            clearSVG();
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', '175'); box.setAttribute('y', '125'); box.setAttribute('width', '150'); box.setAttribute('height', '150');
            box.setAttribute('stroke', '#c7d2fe'); box.setAttribute('stroke-width', '2'); box.setAttribute('fill', 'rgba(129, 140, 248, 0.1)');
            DOM.svg.appendChild(box);

            const wavePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wavePath.setAttribute('fill', 'none'); wavePath.setAttribute('stroke', '#a5b4fc'); wavePath.setAttribute('stroke-width', '3');
            wavePath.style.filter = 'url(#glow)';
            DOM.svg.appendChild(wavePath);

            const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            particle.setAttribute('r', '6'); particle.setAttribute('fill', '#e0e7ff');
            DOM.svg.appendChild(particle);

            let t = 0;
            let isCollapsed = false;

            function animate() {
                if (isCollapsed) return;
                t += 0.02;
                const waveD = `M180 200 C 210 ${200 + Math.sin(t)*30}, 240 ${200 + Math.cos(t)*30}, 270 200 S 300 ${200 - Math.sin(t)*30}, 320 200`;
                wavePath.setAttribute('d', waveD);
                
                const particleX = 250 + Math.sin(t*1.5) * 60;
                const particleY = 200 + Math.cos(t*2) * 40;
                particle.setAttribute('cx', particleX);
                particle.setAttribute('cy', particleY);
                particle.style.opacity = 0.5 + Math.sin(t*3)*0.5;
                box.setAttribute('stroke-dasharray', `${5 + Math.sin(t)*4} ${5 - Math.sin(t)*4}`);
                window.animationFrameId = requestAnimationFrame(animate);
            }
            
            addTrackedListener(DOM.svg, 'click', () => {
                isCollapsed = !isCollapsed;
                if (isCollapsed) {
                    if(window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
                    wavePath.style.display = 'none';
                    particle.style.opacity = '1';
                    box.setAttribute('stroke-dasharray', 'none');
                } else {
                    wavePath.style.display = 'block';
                    animate();
                }
            });
            animate();
        }

        // --- Signal Labyrinth Functions ---

        function drawSignal_Interactive() {
            clearSVG();
            const head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            head.setAttribute('d', 'M200 200 Q 250 150 300 200 T 400 200 Q 350 250 300 200 T 200 200');
            head.setAttribute('fill', 'none'); head.setAttribute('stroke', '#e0e7ff'); head.setAttribute('stroke-width', '2');
            DOM.svg.appendChild(head);

            const dataStreams = [];
            for(let i=0; i<20; i++) {
                const stream = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                stream.setAttribute('fill', 'none');
                stream.setAttribute('stroke', `rgba(165, 180, 252, ${Math.random() * 0.5 + 0.3})`);
                stream.setAttribute('stroke-width', '1.5');
                DOM.svg.appendChild(stream);
                dataStreams.push({el: stream, offset: Math.random() * 100, speed: Math.random() * 10 + 15});
            }

            let t = 0;
            function animate() {
                t += 0.01;
                dataStreams.forEach(s => {
                    const startY = 50 + (s.offset + t * s.speed) % 300;
                    const midY1 = startY + Math.sin(t*2 + s.offset) * 20;
                    const midY2 = startY + Math.cos(t*2 + s.offset) * 20;
                    s.el.setAttribute('d', `M50 ${startY} C 150 ${midY1}, 350 ${midY2}, 450 ${startY}`);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawSignal_Variant1() { // DNA Helix & Data Rain
            clearSVG();
            const wave1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wave1.setAttribute('fill', 'none'); wave1.setAttribute('stroke', '#a5b4fc');
            DOM.svg.appendChild(wave1);
            
            const wave2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wave2.setAttribute('fill', 'none'); wave2.setAttribute('stroke', '#818cf8');
            DOM.svg.appendChild(wave2);

            const dataRain = [];
            for (let i = 0; i < 50; i++) {
                const particle = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const x = Math.random() * 500;
                const y = Math.random() * 400;
                particle.setAttribute('x1', x); particle.setAttribute('y1', y);
                particle.setAttribute('x2', x); particle.setAttribute('y2', y + 5);
                particle.setAttribute('stroke', '#4a5568'); particle.setAttribute('stroke-width', '1');
                DOM.svg.appendChild(particle);
                dataRain.push({ el: particle, x: x, y: y, speed: Math.random() * 2 + 1, corrupted: 0 });
            }

            let t = 0;
            function animate() {
                t += 0.02;
                let d1 = "M 50 200"; let d2 = "M 50 200";
                for (let x = 50; x <= 450; x += 5) {
                    const phase = (x / 100);
                    d1 += ` L ${x} ${200 + Math.sin(t + phase) * 60}`;
                    d2 += ` L ${x} ${200 + Math.sin(t + phase + Math.PI) * 60}`;
                }
                wave1.setAttribute('d', d1);
                wave2.setAttribute('d', d2);
                wave1.setAttribute('stroke-width', 3 + Math.cos(t*2) * 2);
                wave2.setAttribute('stroke-width', 3 - Math.cos(t*2) * 2);

                dataRain.forEach(p => {
                    p.y += p.speed;
                    if (p.y > 405) { p.y = -5; p.x = Math.random() * 500; }

                    const waveY1 = 200 + Math.sin(t + p.x/100) * 60;
                    if (Math.abs(p.y - waveY1) < 5 && p.corrupted <= 0) p.corrupted = 20;

                    if (p.corrupted > 0) {
                        p.el.setAttribute('stroke', '#ef4444');
                        p.corrupted--;
                    } else {
                        p.el.setAttribute('stroke', '#4a5568');
                    }
                    p.el.setAttribute('x1', p.x); p.el.setAttribute('y1', p.y);
                    p.el.setAttribute('x2', p.x); p.el.setAttribute('y2', p.y + 5);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawSignal_Master() {
            const variants = [drawSignal_Variant1, drawSignal_Variant1, drawSignal_Interactive];
            randItem(variants)();
        }


        // --- Thermo Labyrinth Functions ---

        function drawThermo_Variant1() { // Maxwell's Demon
            clearSVG();
            const particles = [];
            const container = { x: 50, y: 50, w: 400, h: 300 };

            for (let i = 0; i < 80; i++) {
                const isHot = i < 40;
                const p = {
                    x: container.x + Math.random() * container.w,
                    y: container.y + Math.random() * container.h,
                    vx: (Math.random() - 0.5) * (isHot ? 2 : 1),
                    vy: (Math.random() - 0.5) * (isHot ? 2 : 1),
                    isHot: isHot,
                    el: document.createElementNS('http://www.w3.org/2000/svg', 'circle')
                };
                p.el.setAttribute('r', isHot ? '3' : '4');
                p.el.setAttribute('fill', isHot ? '#f87171' : '#60a5fa');
                DOM.svg.appendChild(p.el);
                particles.push(p);
            }
            
            let isDrawing = false;
            let demonWall = [];
            const wallLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            wallLine.setAttribute('fill', 'none');
            wallLine.setAttribute('stroke', '#e0e7ff');
            wallLine.setAttribute('stroke-width', '2');
            wallLine.setAttribute('stroke-dasharray', '4 4');
            DOM.svg.appendChild(wallLine);

            addTrackedListener(DOM.svg, 'mousedown', e => {
                isDrawing = true;
                demonWall = [];
                wallLine.setAttribute('points', '');
            });

            addTrackedListener(DOM.svg, 'mousemove', e => {
                if (!isDrawing) return;
                const rect = DOM.svg.getBoundingClientRect();
                const viewBox = DOM.svg.viewBox.baseVal;
                const x = (e.clientX - rect.left) * (viewBox.width / rect.width);
                const y = (e.clientY - rect.top) * (viewBox.height / rect.height);
                demonWall.push({ x, y });
                wallLine.setAttribute('points', demonWall.map(p => `${p.x},${p.y}`).join(' '));
            });
            
            addTrackedListener(DOM.svg, 'mouseup', () => { isDrawing = false; });

            function animate() {
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < container.x + 3 || p.x > container.x + container.w - 3) p.vx *= -1;
                    if (p.y < container.y + 3 || p.y > container.y + container.h - 3) p.vy *= -1;

                    // Simple wall implementation: sort particles based on which side of the wall's start-Y they are
                    if (demonWall.length > 1) {
                        const wallY = demonWall[0].y;
                        if (p.isHot && p.y > wallY) p.vy -= 0.1; // Hot particle below wall, push up
                        if (!p.isHot && p.y < wallY) p.vy += 0.1; // Cold particle above wall, push down
                    }
                    
                    p.el.setAttribute('cx', p.x);
                    p.el.setAttribute('cy', p.y);
                });
                window.animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawThermo_Master() {
            const variants = [drawThermo_Variant1]; // Prioritizing the new interactive version
            randItem(variants)();
        }

        // --- MASTER DRAWING DISPATCHER ---
        const drawFuncs = {
            spatial: drawSpatial_Master,
            temporal: drawTemporal_Interactive,
            quantum: drawQuantum_Interactive,
            thermo: drawThermo_Master,
            signal: drawSignal_Master,
            default: drawSpatial_Master
        };

        // --- DEFAULT DATA ---
        const defaultLabyrinthTypes = {
            spatial: { name: "Spatial", title: "Architectural Labyrinth (Non-Euclidean)", threat: 4, scenarios: ["A research team is lost inside; their last transmission was 'the map is lying'."], threats: ["Permanent entrapment due to unsolvable topology."], evidence: ["Nav-logs show a ship traveling in a straight line for 10km but ending up at its starting point."], description: "<h4>Primary Paradox:</h4><p>Violation of Euclidean geometry. Manifolds are locally folded, creating impossible connections.</p><h4>Known Variants:</h4><ul><li>Penrose Stairways</li><li>Tesseract Chambers</li></ul><h4>Containment:</h4><p>Uncontained. Standard mapping is useless.</p>" },
            temporal: { name: "Temporal", title: "Temporal Labyrinth (Causal Anomaly)", threat: 7, warning: "High Risk", scenarios: ["An explorer emerges claiming to be from 20 years in the future."], threats: ["Rapid aging to death in seconds."], evidence: ["A weapon that is simultaneously rusted and brand new."], description: "<h4>Primary Paradox:</h4><p>Violation of linear time progression and causality.</p><h4>Known Variants:</h4><ul><li>D√©j√† Vu Loops</li><li>Stasis Fields</li></ul><h4>Containment:</h4><p>Partially contained, but causal contamination is a constant risk.</p>" },
            quantum: { name: "Quantum", title: "Quantum Labyrinth (Macro-State Anomaly)", threat: 5, scenarios: ["A rival faction wants to collapse the Labyrinth into a specific, favorable state."], threats: ["Accidentally observing a lethal state into existence."], evidence: ["Video logs that change every time they are played."], description: "<h4>Primary Paradox:</h4><p>Quantum weirdness manifests at classical scales.</p><h4>Known Variants:</h4><ul><li>Cheshire Walls</li><li>Entangled Rooms</li></ul><h4>Containment:</h4><p>Uncontained. The 'Observer Effect' makes study difficult and dangerous.</p>" },
            thermo: { name: "Thermo", title: "Thermodynamic Labyrinth (Entropic Anomaly)", threat: 6, scenarios: ["The Labyrinth is siphoning heat from the surrounding region, causing a localized ice age."], threats: ["Flash freezing or incineration in adjacent corridors."], evidence: ["A perpetually burning fire in a vacuum-sealed chamber."], description: "<h4>Primary Paradox:</h4><p>Localized violation of the Second Law of Thermodynamics.</p><h4>Known Variants:</h4><ul><li>Perpetual Motion Chambers</li><li>Reassembly Forges</li></ul><h4>Containment:</h4><p>Contained by thermal insulation, but leaks can cause catastrophic environmental shifts.</p>" },
            signal: { name: "Signal", title: "Signal Labyrinth (Informational Anomaly)", threat: 8, warning: "Extreme Risk", scenarios: ["The Labyrinth has infected the team's comms officer."], threats: ["Irreversible insanity from exposure to a logical paradox."], evidence: ["A computer core that melted down after trying to compute 'the last digit of pi'."], description: "<h4>Primary Paradox:</h4><p>Information that has no discernible physical source or violates logical principles.</p><h4>Known Variants:</h4><ul><li>Basilisk Stare</li><li>Logic Bombs</li></ul><h4>Containment:</h4><p>Requires total network isolation ('air gapping').</p>" }
        };
        const defaultArtifacts = { 'TAE-001': { id: 'TAE-001', name: 'Causal Loop Crystal', description: '<p>A crystalline structure that appears to locally violate causality, causing events within its field to repeat in a closed loop. Analysis is ongoing. This is default local data.</p>', source: 'Temporal Labyrinth', hazard: 'Causal Contamination' } };
        const missionData = {
            objectives: ["Investigate", "Retrieve", "Rescue", "Contain", "Destroy", "Stabilize"],
            subjects: ["a research team", "a high-value artifact", "a missing operative", "an unstable energy source", "a rival faction's asset"],
            locations: { surface: ["abandoned mining outpost", "crashed colony ship", "ancient Eryxian ritual site"], orbital: ["a derelict research station", "a defensive satellite", "a space elevator terminus"], space: ["a deep space probe", "a rogue asteroid colony", "a ghost ship"] },
            factions: ["The Stellar Concord", "Terran Ascendancy Mandate (TAM)", "Fractured Humanity Conglomerate", "Pyran Ascendancy", "Eryxian Natives"],
            diseases: ["Causal Rot", "Geometric Cancer", "Temporal Arteritis", "Dimensional Dementia"]
        };
        currentLabyrinthTypes = defaultLabyrinthTypes;
        currentArtifacts = defaultArtifacts;

        // --- WIKI PARSER & FETCHER ---
        function parseWikiData(markdown) {
            const dataRegion = markdown.split('<!-- ERYXIAN-LABYRINTHS-DATA-START -->')[1]?.split('<!-- ERYXIAN-LABYRINTHS-DATA-END -->')[0];
            if (!dataRegion) throw new Error("Could not find data block comments in wiki content.");
            const [classificationsBlock, artifactsBlock] = dataRegion.split('## Labyrinth Artifact Catalog');
            
            const parsedLabyrinths = {};
            classificationsBlock.split('### Labyrinth:').slice(1).forEach(block => {
                const lines = block.trim().split('\n');
                const name = lines[0].trim().toLowerCase();
                if (!name) return;
                const labData = { name: lines[0].trim(), scenarios:[], threats:[], evidence:[], variants:[] };
                let currentList = null, isDescription = false;
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('> Description:')) { isDescription = true; labData.description = ''; continue; }
                    if (isDescription) { labData.description += line.replace(/^>\s?/, ''); continue; }
                    const simplePropMatch = line.match(/^\*\s+([^:]+):\s*(.*)/);
                    if (simplePropMatch) {
                        isDescription = false;
                        const key = simplePropMatch[1].trim(), value = simplePropMatch[2].trim();
                        if (['scenarios', 'threats', 'evidence', 'variants'].includes(key)) { currentList = key; labData[key] = labData[key] || []; }
                        else { labData[key] = value; currentList = null; }
                    } else if (currentList && line.match(/^\s+\*\s/)) { labData[currentList].push(line.replace(/^\s+\*\s+/, '').trim()); }
                }
                if (labData.description && labData.warning) labData.description += `<span class='physics-warning'>${labData.warning}</span>`;
                parsedLabyrinths[name] = labData;
            });

            const parsedArtifacts = {};
            if(artifactsBlock) {
                artifactsBlock.split('### Artifact:').slice(1).forEach(block => {
                    const lines = block.trim().split('\n');
                    const id = lines[0].trim();
                    if(!id) return;
                    const artData = { id };
                    let isDescription = false;
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.startsWith('> Description:')) { isDescription = true; artData.description = ''; continue; }
                        if(isDescription) { artData.description += line.replace(/^>\s?/, ''); continue; }
                        const match = line.match(/\*\s*([^:]+):\s*(.*)/);
                        if(match) {
                            isDescription = false;
                            artData[match[1].trim().toLowerCase().replace(' ', '_')] = match[2].trim();
                        }
                    }
                    parsedArtifacts[id] = artData;
                });
            }
            if (Object.keys(parsedLabyrinths).length > 0) liveLabyrinthTypes = parsedLabyrinths; else throw new Error("No Labyrinth types found.");
            if (Object.keys(parsedArtifacts).length > 0) liveArtifacts = parsedArtifacts;
        }

        async function fetchWikiData() {
            setSyncStatus('syncing');
            try {
                const response = await fetch(WIKI_URL);
                if (!response.ok) throw new Error(`Network response: ${response.statusText}`);
                parseWikiData(await response.text());
                currentLabyrinthTypes = liveLabyrinthTypes;
                currentArtifacts = liveArtifacts;
                setSyncStatus('synced');
            } catch (error) {
                console.error('Wiki Sync Error:', error);
                currentLabyrinthTypes = defaultLabyrinthTypes;
                currentArtifacts = defaultArtifacts;
                setSyncStatus('failed');
            } finally {
                setupViewer();
                if(document.getElementById('content-database').offsetParent !== null) setupArtifactDatabase();
            }
        }
        function setSyncStatus(status) {
            const labels = document.querySelectorAll('.wiki-sync-label');
            const checkboxes = document.querySelectorAll('.wiki-sync-checkbox');
            let text, colorClass, isChecked, isDisabled;
            switch(status) {
                case 'syncing': text = 'Syncing...'; colorClass = 'text-yellow-400'; isChecked = true; isDisabled = true; break;
                case 'synced': text = `Synced (${Object.keys(liveLabyrinthTypes).length} types, ${Object.keys(liveArtifacts).length} artifacts)`; colorClass = 'text-green-400'; isChecked = true; isDisabled = false; break;
                case 'failed': text = 'Sync Failed (Using Default)'; colorClass = 'text-red-400'; isChecked = false; isDisabled = false; break;
                default: text = 'Sync with Live Wiki Data'; colorClass = 'text-gray-400'; isChecked = false; isDisabled = false;
            }
            labels.forEach(l => { l.textContent = text; l.className = `wiki-sync-label text-sm ${colorClass}`; });
            checkboxes.forEach(c => { c.checked = isChecked; c.disabled = isDisabled; });
        }
        
        // --- VIEWER & GENERATOR LOGIC ---
        function setupViewer() {
            DOM.schematicButtonsContainer.innerHTML = '';
            const typeKeys = Object.keys(currentLabyrinthTypes);
            if (typeKeys.length === 0) return;
            typeKeys.forEach(key => {
                const btn = document.createElement('button');
                btn.id = `btn-${key}`; btn.className = 'schematic-btn text-xs sm:text-sm font-medium py-2 px-3 rounded-md'; btn.textContent = currentLabyrinthTypes[key].name;
                btn.addEventListener('click', () => selectLabyrinthType(key));
                DOM.schematicButtonsContainer.appendChild(btn);
            });
            selectLabyrinthType(typeKeys[0]);
        }
        function selectLabyrinthType(typeKey) {
            const type = currentLabyrinthTypes[typeKey];
            if (!type) { console.error(`Type ${typeKey} not found.`); return; }
            document.querySelectorAll('.schematic-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${typeKey}`)?.classList.add('active');
            const threatLevels = {1:'low',2:'low',3:'low',4:'medium',5:'medium',6:'medium',7:'high',8:'high',9:'extreme',10:'extreme'};
            const threatClass = threatLevels[type.threat] || 'low';
            let threatHTML = type.threat ? `<div class="threat-indicator threat-${threatClass}"><p class="text-sm font-semibold">Threat Level: ${type.threat}/10</p></div>` : '';
            DOM.infoPanel.innerHTML = `<h3>${type.title}</h3>${type.description || '<p>No description available.</p>'}${threatHTML}`;
            (drawFuncs[typeKey] || drawFuncs.default)();
        }
        function generateGMContent(contentType) {
            const typeKey = randItem(Object.keys(currentLabyrinthTypes));
            const typeData = currentLabyrinthTypes[typeKey];
            let contentList = typeData[contentType];
            if (!contentList || contentList.length === 0) { DOM.generatorOutput.innerHTML = `<p class="text-gray-500">No '${contentType}' data for ${typeData.name} Labyrinth. Update the wiki!</p>`; return; }
            const randomItem = randItem(contentList);
            const titles = { scenarios: 'üé≤ Scenario Hook', threats: '‚ö†Ô∏è Threat Assessment', evidence: 'üîç Field Evidence' };
            DOM.generatorOutput.innerHTML = `<div class="border-l-4 border-purple-500 pl-4"><h4 class="font-semibold text-purple-300 mb-2">${titles[contentType]}</h4><p class="text-gray-300 leading-relaxed">${randomItem}</p></div>`;
        }
        function generateMissionBrief() {
            const labTypeKey = randItem(Object.keys(currentLabyrinthTypes));
            const labyrinth = currentLabyrinthTypes[labTypeKey];
            const artifactList = Object.values(currentArtifacts);
            const artifact = randItem(artifactList);
            if (!artifact) { DOM.generatorOutput.innerHTML = '<p class="text-red-400">Error: No artifacts available to generate a mission.</p>'; return; }
            DOM.generatorOutput.innerHTML = `<h4 class="text-lg font-bold text-purple-300 mb-2 border-b border-purple-800 pb-1">MISSION BRIEFING</h4> <p><strong>Objective:</strong> ${randItem(missionData.objectives)} <strong class="text-yellow-300">${artifact.name} (${artifact.id})</strong>.</p> <p><strong>Location:</strong> A <strong class="text-yellow-300">${randItem(missionData.locations[DOM.locationSelect.value])}</strong>.</p> <p><strong>Anomaly Type:</strong> <strong class="text-yellow-300">${labyrinth.title}</strong>.</p> <p><strong>Primary Threat:</strong> <strong class="text-red-400">${randItem(labyrinth.threats) || "Unknown"}</strong></p> <p><strong>Complication:</strong> <strong class="text-yellow-300">${randItem(missionData.factions)}</strong> is also on-site.</p> <p><strong>Further Analysis:</strong> Anomaly shows signs of <strong class="text-red-400">${randItem(missionData.diseases)}</strong>.</p>`;
        }

        // --- ARTIFACT DATABASE LOGIC ---
        function setupArtifactDatabase() {
            renderArtifactList();
            DOM.artifactSearch.addEventListener('input', renderArtifactList);
        }
        function renderArtifactList() {
            const searchTerm = DOM.artifactSearch.value.toLowerCase();
            const artifactList = Object.values(currentArtifacts).filter(art => art.name.toLowerCase().includes(searchTerm) || art.id.toLowerCase().includes(searchTerm));
            DOM.artifactList.innerHTML = '';
            artifactList.forEach(art => {
                const btn = document.createElement('button');
                btn.id = `artbtn-${art.id}`;
                btn.className = 'artifact-btn text-left w-full p-2 rounded-md text-sm';
                btn.innerHTML = `<span class="font-semibold">${art.id}</span>: ${art.name}`;
                btn.addEventListener('click', () => selectArtifact(art.id));
                DOM.artifactList.appendChild(btn);
            });
            if (artifactList.length > 0) {
                 selectArtifact(artifactList[0].id);
            } else {
                 DOM.artifactDetailsContainer.classList.add('hidden');
            }
        }
        function selectArtifact(id) {
            const art = currentArtifacts[id];
            if(!art) return;
            document.querySelectorAll('.artifact-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`artbtn-${id}`)?.classList.add('active');
            
            let detailsHTML = `<h3>${art.name} <span class="text-sm font-normal text-gray-400">(${art.id})</span></h3>`;
            if (art.source) detailsHTML += `<h4>Source</h4><p>${art.source}</p>`;
            if (art.hazard) detailsHTML += `<h4>Hazard Type</h4><p>${art.hazard}</p>`;
            if (art.description) detailsHTML += `<h4>Description</h4><p>${art.description}</p>`;
            if (art.image_url) detailsHTML += `<img src="${art.image_url}" alt="Schematic for ${art.name}">`;
            
            DOM.artifactDetails.innerHTML = detailsHTML;
            DOM.artifactDetailsContainer.classList.remove('hidden');
        }

        // --- SIMULATOR LOGIC ---
        let paradoxState = {};
        function startParadoxSim() {
            paradoxState = { step: 0 };
            DOM.paradoxLog.innerHTML = '';
            updateParadoxLog('log-system', 'SIMULATION START: Threshold Gate Anomaly...');
            updateParadoxLog('log-time', '[10:55:00] Preparing Maintenance Drone D-7 for launch at [11:00:00].');
            setTimeout(() => {
                updateParadoxLog('log-alert', '[10:59:01] ALERT: Maintenance Drone D-7 emerges from Gate.');
                updateParadoxLog('log-info', '[10:59:02] Identical to drone D-7. Causal violation detected. Orders?');
                renderParadoxChoices();
            }, 500);
        }
        function updateParadoxLog(type, text) { DOM.paradoxLog.innerHTML += `<p><span class="${type}">${text}</span></p>`; DOM.paradoxLog.scrollTop = DOM.paradoxLog.scrollHeight; }
        function renderParadoxChoices() {
            DOM.paradoxChoices.innerHTML = '';
            if (paradoxState.step === 0) {
                DOM.paradoxChoices.innerHTML = `<button data-choice="send" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Proceed</button> <button data-choice="abort" class="btn-secondary text-white px-4 py-2 rounded-lg text-sm">Abort</button> <button data-choice="mark" class="btn-secondary text-white px-4 py-2 rounded-lg text-sm">Mark & Send</button>`;
            } else {
                DOM.paradoxChoices.innerHTML = `<button data-choice="restart" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Run Again</button>`;
            }
        }
        
        let probeState = {};
        function startProbeSim() { probeState = { currentNodeId: 'node-0' }; DOM.probeLog.innerHTML = ''; updateProbeLog('log-system', `Launching deep exploration probe...`); renderProbeNode(); }
        function generateProbeNode(nodeId) {
            const typeKey = randItem(Object.keys(currentLabyrinthTypes)); const typeData = currentLabyrinthTypes[typeKey];
            if (nodeId === 'node-0') return { description: 'Initial entry point. The air hums with anomalous energy.', choices: { 'Proceed cautiously': 'node-1' } };
            if(Math.random() < 0.3) return { description: `${randItem(typeData.threats) || "Catastrophic failure"}. Probe sensors overload. Signal lost.`, choices: {} };
            return { description: `Probe detects: ${randItem(typeData.evidence) || "strange readings"}.`, choices: { 'Go Left': `node-${Math.random()}`, 'Go Right': `node-${Math.random()}` } };
        }
        function renderProbeNode() {
            const node = generateProbeNode(probeState.currentNodeId); updateProbeLog('log-probe', `[NODE ${probeState.currentNodeId.substring(0,6)}] ${node.description}`); DOM.probeChoices.innerHTML = '';
            if (Object.keys(node.choices).length === 0) DOM.probeChoices.innerHTML = `<button data-choice="restart" class="btn-primary text-white px-4 py-2 rounded-lg text-sm">Launch New Probe</button>`;
            else Object.entries(node.choices).forEach(([text, targetNodeId]) => { const btn = document.createElement('button'); btn.className = 'btn-secondary text-white px-4 py-2 rounded-lg text-sm'; btn.textContent = text; btn.dataset.target = targetNodeId; DOM.probeChoices.appendChild(btn); });
        }
        function updateProbeLog(type, text) { DOM.probeLog.innerHTML += `<p><span class="${type}">${text}</span></p>`; DOM.probeLog.scrollTop = DOM.probeLog.scrollHeight; }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            DOM = {
                svg: document.getElementById('schematic-svg'), infoPanel: document.getElementById('info-panel'), schematicButtonsContainer: document.getElementById('schematic-buttons'), generatorOutput: document.getElementById('generator-output'),
                locationSelect: document.getElementById('location-select'), paradoxLog: document.getElementById('paradox-log'), paradoxChoices: document.getElementById('paradox-choices'), probeLog: document.getElementById('probe-log'), probeChoices: document.getElementById('probe-choices'),
                allTabs: document.querySelectorAll('.main-tab'), allContent: document.querySelectorAll('[id^="content-"]'), allSyncCheckboxes: document.querySelectorAll('.wiki-sync-checkbox'),
                artifactList: document.getElementById('artifact-list'), artifactSearch: document.getElementById('artifact-search'), artifactDetails: document.getElementById('artifact-details'), artifactDetailsContainer: document.getElementById('artifact-details-container')
            };
            
            DOM.allTabs.forEach(tab => tab.addEventListener('click', e => {
                const targetTab = e.target.dataset.tab;
                DOM.allTabs.forEach(t => t.classList.remove('active')); e.target.classList.add('active');
                DOM.allContent.forEach(c => { c.classList.add('hidden'); c.classList.remove('grid'); });
                const targetContent = document.getElementById(`content-${targetTab}`);
                targetContent.classList.remove('hidden');
                
                if(['viewer', 'database', 'simulator'].includes(targetTab)) targetContent.classList.add('grid');
                if(targetTab === 'viewer' && Object.keys(currentLabyrinthTypes).length > 0) selectLabyrinthType(document.querySelector('.schematic-btn.active')?.id.replace('btn-', '') || Object.keys(currentLabyrinthTypes)[0]);
                if(targetTab === 'simulator') { startParadoxSim(); startProbeSim(); }
                if(targetTab === 'database') setupArtifactDatabase();
            }));

            DOM.allSyncCheckboxes.forEach(checkbox => checkbox.addEventListener('change', e => {
                if (e.target.checked) fetchWikiData();
                else { 
                    currentLabyrinthTypes = defaultLabyrinthTypes; 
                    currentArtifacts = defaultArtifacts;
                    setSyncStatus('default'); 
                    setupViewer();
                    if(document.getElementById('content-database').offsetParent !== null) setupArtifactDatabase();
                }
            }));

            document.getElementById('gm-brief').addEventListener('click', generateMissionBrief);
            document.getElementById('gm-scenario').addEventListener('click', () => generateGMContent('scenarios'));
            document.getElementById('gm-threat').addEventListener('click', () => generateGMContent('threats'));
            document.getElementById('gm-evidence').addEventListener('click', () => generateGMContent('evidence'));

            DOM.paradoxChoices.addEventListener('click', e => {
                const choice = e.target.dataset.choice; if (!choice) return;
                if (choice === 'restart') { startParadoxSim(); return; }
                paradoxState.step = 1; updateParadoxLog('log-action', `[DECISION] ${e.target.textContent}`);
                switch(choice) {
                    case 'send': updateParadoxLog('log-info', '[11:00:00] Drone enters Gate. Loop closed. Event self-consistent.'); break;
                    case 'abort': updateParadoxLog('log-alert', '[11:00:00] Drone wrenched from grasp, flies into Gate. Labyrinth enforces consistency.'); break;
                    case 'mark': updateParadoxLog('log-info', '[10:59:30] Mark appears on emerged drone. Labyrinth enforces consistency retroactively.'); break;
                }
                updateParadoxLog('log-system', 'SIMULATION COMPLETE.'); renderParadoxChoices();
            });

            DOM.probeChoices.addEventListener('click', e => {
                const choice = e.target.dataset.choice; const targetNode = e.target.dataset.target;
                if (choice === 'restart') { startProbeSim(); return; } 
                if (!targetNode) return;
                probeState.currentNodeId = targetNode; renderProbeNode();
            });

            setupViewer();
        });
    </script>
</body>
</html>